---
title: 방어적 복사
description: 방어적 복사는 무엇인가요?
date: 2026-01-09
tags: [방어적 복사]
---

방어적 복사는 객체의 내부 상태(필드)를 외부의 변경으로부터 보호하기 위해, 데이터의 참조(주소)가 아닌 복사본을 만들어 전달하는 기법입니다.

Java와 같이 참조에 의한 전달이 일어나는 언어에서, 객체의 불변성과 캡슐화를 지키기 위한 필수적인 테크닉입니다.

## 1. 문제 상황

Java에서 객체나 컬렉션(List 등)을 주고 받을 때, 실제 값이 아니라 메모리 주소값이 전달됩니다. 만약 생성자나 Getter에서 이 주소값을 그대로 주고받으면, 외부에서 객체 내부의 값을 마음대로 조작할 수 있게 됩니다.

방어적 복사를 안했을 때 (보안 구멍)

```java
import java.util.ArrayList;
import java.util.List;

public class Team {
    private final List<String> members;

    // 1. 생성자: 외부 리스트를 그대로 받음 (위험!)
    public Team(List<String> members) {
        this.members = members;
    }

    // 2. Getter: 내부 리스트를 그대로 반환 (위험!)
    public List<String> getMembers() {
        return members;
    }
}

// 사용 예시
List<String> original = new ArrayList<>();
original.add("Alice");

Team team = new Team(original);

// 문제 1: 생성자로 넘긴 원본을 밖에서 수정하면 Team 내부도 바뀜
original.add("Bob"); // Team 내부에도 Bob이 추가됨 (캡슐화 깨짐)

// 문제 2: Getter로 받은 리스트를 수정하면 Team 내부도 바뀜
team.getMembers().add("Hacker"); // Team 내부에 Hacker가 추가됨
```

위 코드에서 Team은 자신의 멤버를 관리하지 못합니다. 외부 코드가 Team의 허락 없이 멤버를 추가하거나 삭제할 수 있기 때문입니다.

## 2. 방어적 복사 적용 (해결 방법)

이 문제를 해결하려면 “들어올 때 복사하고, 나갈 때 복사해야”합니다.

### 1) 생성자에서의 방어적 복사

외부에서 넘겨준 리스트와 Team 내부의 리스트가 서로 다른 주소를 가지도록 복사해서 저장합니다.

```java
public Team(List<String> members) {
    // 새로운 ArrayList를 만들어서 값을 옮겨 담음
    this.members = new ArrayList<>(members);
}
```

### 2) Getter에서의 방어적 복사

내부 리스트의 주소를 그대로 주지 않고, 복사본을 만들어서 반환하거나 수정 불가능한 뷰를 반환합니다.

```java
// 방법 A: 복사본 반환 (안전)
public List<String> getMembers() {
    return new ArrayList<>(this.members);
}

// 방법 B: 수정 불가능한 리스트 반환 (권장)
public List<String> getMembers() {
    return Collections.unmodifiableList(this.members);
}
```

- Collections.unmodifiableList()를 사용하면, 외부에서 add()나 remove()를 호출할 때 예외가 발생하여 수정을 막습니다.

## 3. 깊은 복사 vs 얕은 복사

방어적 복사를 할 때 가장 주의해야 할 점입니다. new ArrayList<>(list)는 리스트 자체는 새로 만들지만, 리스트 안에 들어있는 객체들은 주소만 복사(얕은 복사)합니다.

- String, Integer 같은 불변 객체: 얕은 복사만 해도 안전합니다. (값이 안변하니까)
- Person, Car 같은 가변 객체: 얕은 복사로는 부족합니다. 리스트는 따로따로지만, 리스트 안의 Person 객체는 여전히 공유되기 때문입니다.

따라서 컬렉션 내부의 객체가 가변이라면, 내부 객체까지 일일이 새로 생성해주는 ‘깊은 복사’를 수행해야 진정한 방어적 복사가 됩니다.

## 정리

방어적 복사는 “객체를 믿지 말고, 외부도 믿지 말라”는 철학입니다.

1. 생성자: 외부에서 받은 인자는 언제든 변할 수 있으니, 복사해서 내부에 저장합니다.
2. Getter: 내부 필드를 그대로 내보내면 외부에서 조작할 수 있으니, 복사본이나 읽기 전용 뷰를 반환합니다.
3. 목적: 객체의 불변성 유지와 견고한 캡슐화
