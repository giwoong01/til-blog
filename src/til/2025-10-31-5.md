---
title: JPA의 N + 1
description: JPA의 N + 1 은 무엇일까요? 실제 예시와 함께 봅시다.
date: 2025-10-31
tags: [Spring Boot, JPA, N+1]
---

# N+1은 무엇인가

JPA를 사용할 때 일어나는 일입니다.

JPA의 연관 관계가 있는 엔티티를 조회할 경우, 조회된 데이터 개수(N)만큼 연관 관계가 있는 데이터를 추가로 조회하는 쿼리를 발생시키는 문제입니다.

하나의 조회 쿼리 (N=1) 이후, 연관된 엔티티를 접근할 때마다 추가 쿼리(N번)가 발생하는 현상입니다.

# N+1 원인, 예시

연관 관계 매핑 시 지연 로딩 (Lazy Loading) 설정이 되어 있을 때 발생합니다. 초기에는 부모 엔티티만 조회하고, 자식 엔티티는 실제로 사용될 때 로딩되도록 설정되어 있기때문입니다. 이때 부모 엔티티의 개수만큼 자식엔티티를 조회하는 쿼리가 추가로 실행됩니다.

```java
@Entity
public class Member {
    @Id @GeneratedValue
    private Long id;

    private String name;

    @ManyToOne(fetch = FetchType.LAZY)
    private Team team;
}

@Entity
public class Team {
    @Id @GeneratedValue
    private Long id;

    private String name;
}
```

N+1 문제 발생 코드

```java
List<Member> members = memberRepository.findAll();  // 1번 쿼리 (Member)

for (Member m : members) {
    System.out.println(m.getTeam().getName());      // N번 쿼리 (Team)
}
```

@ManyToOne의 fetchType LAZY 설정.

getTeam() 호출 시마다 team 조회 쿼리가 실행됩니다.

팀이 10명이면 총 1 + 10 = 11번 쿼리가 발생합니다.

### 실제 테스트

![image.png](/images/til/2025-10-31-5/1.png)

위와 같이 미리 데이터를 세팅해둡니다.

![image.png](/images/til/2025-10-31-5/2.png)

해당 코드를 실행하게 되면?

![image.png](/images/til/2025-10-31-5/3.png)

이와 같이 여러개의 select 쿼리가 실행됩니다.

이 부분이 N+1 문제입니다.

![image.png](/images/til/2025-10-31-5/4.png)

member select 쿼리 1번

![image.png](/images/til/2025-10-31-5/5.png)

getTeam select 쿼리 N번

이와 같이 쿼리가 더 나가게 되면 DB 조회로 인해서 성능이 저하될 수 있습니다.

> 위 로직을 실행할 때, @Transactional 어노테이션이 없으면 LazyInitializationException 에러가 발생한다. 이 에러는 Hibernate에서 엔티티의 지연 로딩을 시도할 때 세션이 닫혀 있거나 존재하지 않을 경우 발생한다.
>
> 그래서 @Transactional 어노테이션을 붙여야하는데, 이 설정은 Hibernate와 같은 ORM에서 Lazy Loading을 지원하는데 중요한 역할을 한다.
>
> 1. 트랜잭션 관리
>    @Transactional이 붙은 메소드는 Spring이 트랜잭션을 시작하고 관리한다. 트랜잭션이 활성화되면 Hibernate는 엔티티를 지연 로딩할 때 필요한 세션을 유지한다. 그래서 위와 같은 에러를 방지할 수 있다.
>
> 2. Lazy Loading 지원
>    LazyLoading은 엔티티의 연관 데이터를 실제로 접근할 때 로드한다. 트랜잭션이 없으면 Hibernate는 세션을 닫아버리기 때문에 Lazy Loading이 실패한다. @Transactional을 사용하면 트랜잭션이 유지되므로 Lazy Loading이 정상적으로 작동한다.

> 사실 설정마다 다르긴하다.
> @Transactional 어노테이션이 없어도 `open-in-view: true` 이면 LazyInitializationException 에러가 발생하지 않는다.
>
> 그 이유는 osiv가 true이면 영속성 전이가 뷰까지 진행이 되기 때문이다. (뷰 렌더링까지 영속성 컨텍스트를 열어둔다.)
>
> 기본이 true이기 때문에 따로 설정을 하지 않으면 LazyInitializationException 에러가 발생하지 않는다.
>
> 하지만 단점으로는 트랜잭션이 이미 끝나도 DB 커넥션을 잡고 있을 수 있다. 그리고 N + 1문제 유발, 서비스 계층이 아닌 뷰 단에서 DB접근이 가능하다.
>
> osiv 설정을 false로 한다면, 트랜잭션을 종료할때 영속성 컨텍스트도 닫고 데이터베이스 커넥션도 반환한다.

# 해결방법

## 1. Fetch Join

![image.png](/images/til/2025-10-31-5/6.png)

![image.png](/images/til/2025-10-31-5/7.png)

SQL 조인으로 member와 team을 한 번에 조회합니다.

![image.png](/images/til/2025-10-31-5/8.png)

결과를 보면 쿼리가 1번만 나가는 것을 볼 수 있습니다..

하지만 페이징 지원이 제한됩니다.

## 2. EntityGraph

EntityGraph는 JPA에서 엔티티와 연관된 다른 엔티티들을 함께 로딩하는 전략을 정의하는 메커니즘입니다.

즉, 연관된 엔티티들을 즉시 로딩할지, 지연 로딩할지, 또는 어떤 엔티티들을 함께 로딩할지 등을 설정할 수 있습니다.

![image.png](/images/til/2025-10-31-5/9.png)

![image.png](/images/til/2025-10-31-5/10.png)

EntityGraph는 JPQL없어도 fetch join 효과를 줄 수 있습니다.

스프링 데이터 JPA에서 많이 사용합니다.

![image.png](/images/til/2025-10-31-5/11.png)

## 3. DTO

DTO로 직접 조회 하게 되면 필요한 필드만 조회가 가능하기 때문에 성능이 가장 우수합니다.

하지만 복잡한 경우 쿼리 작성이 많아집니다.

![image.png](/images/til/2025-10-31-5/12.png)

![image.png](/images/til/2025-10-31-5/13.png)

![image.png](/images/til/2025-10-31-5/14.png)

## 이 외

이 외에도 Batch Fetching 설정 (Hibernate 기능)도 가능합니다.

# 정리

N + 1 문제는 지연 로딩으로 인해, 연관된 엔티티를 사용할 때마다 추가 쿼리가 발생하는 문제입니다.

즉, 1개의 조회 쿼리로 N개의 엔티티를 불러오면서 N + 1번의 쿼리가 실행되는 현상입니다.

이를 해결하기 위해서는 fetch join을 사용하거나 EntityGraph, batch size 설정, DTO Projection을 통해 연관 데이터를 한번에 로딩하도록 최적화 할 수 있습니다.
