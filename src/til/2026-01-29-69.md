---
title: 트랜잭셔널 아웃박스 패턴
description: 트랜잭셔널 아웃박스 패턴은 무엇인가요?
date: 2026-01-29
tags: [트랜잭셔널 아웃박스]
---

트랜잭셔널 아웃박스 패턴(Transactional Outbox Pattern)은 분산 시스템(마이크로서비스) 환경에서 “데이터베이스 업데이트”와 “메시지 발행(이벤트 발행)”을 원자적으로 처리하기 위한 패턴입니다.

쉽게 말해, “DB에는 저장이 됐는데, 카프카(메시지 큐)에는 메시지가 안 날아가는 상황”을 원천적으로 막기 위한 안전장치입니다.

## 1. 왜 필요한가요? (Dual Write 문제)

마이크로서비스에서 ‘주문’ 서비스를 개발한다고 가정해 봅시다. 주문이 들어오면 두 가지 일을 해야 합니다.

1. DB 저장: 주문 테이블에 주문 정보를 INSERT 한다.
2. 이벤트 발행: 배송 서비스가 알 수 있도록 메시지 브로커(Kafka 등)에 OrderCreated 이벤트를 보낸다.

만약 코드를 이렇게 짰다면 문제가 생깁니다.

```java
@Transactional
public void placeOrder(Order order) {
    // 1. DB 저장 (성공)
    orderRepository.save(order);

    // 2. 메시지 발행 (네트워크 오류로 실패!)
    kafkaProducer.send("order-topic", order);
}
```

- 문제 상황: DB 트랜잭션은 커밋되어 주문은 생성되었는데, 메시지 전송이 실패해서 배송 서비스는 주문이 들어온 줄 모릅니다. (데이터 불일치 발생)
- 반대로 메시지를 먼저 보내고 DB를 나중에 저장해도, DB 저장이 실패하면 메시지만 나가는 문제가 생깁니다.

이런 Dual Write(두 저장소에 동시에 쓰기) 문제를 해결하기 위해 아웃박스 패턴이 등장했습니다.

## 2. 아웃박스 패턴의 동작 원리

핵심 아이디어는 “메시지 큐에 보낼 내용을 일단 DB에 같이 저장하자”는 것입니다. RDBMS의 트랜잭션(ACID)를 이용하는 것이죠.

단계 1: 로컬 트랜잭션 (저장)

비즈니스 데이터를 저장할 때, 보낼 메시지도 같은 DB 안의 별도 테이블(OUTBOX)에 함께 저장합니다.

- 트랜잭션 시작
  1. `INSERT INTO ORDER …` (주문 정보 저장)
  2. `INSERT INTO OUTBOX …` (발행할 이벤트 내용 저장)
- 트랜잭션 커밋

이렇게 하면 DB의 트랜잭션 성질에 의해, 주문과 아웃박스 메시지는 “둘 다 저장되거나, 둘 다 저장되지 않음”이 보장됩니다.

단계 2: 메시지 릴레이 (전송)
이제 DB의 OUTBOX 테이블에 저장된 메시지를 꺼내서 실제 메시지 브로커(Kafka)로 보내주는 별도의 프로세스가 필요합니다.

## 3. 메시지 릴레이 구현 방식

OUTBOX 테이블에 있는 데이터를 어떻게 브로커로 옮길지에 따라 두 가지 방식이 있습니다.

1. 폴링 발행기 (Polling Publisher)
   - 방법: 별도의 스케줄러가 주기적으로 `SELECT * FROM OUTBOX WHERE published = false` 쿼리를 날려 데이터를 읽어오고, 메시지 큐에 전송한 뒤 `published = true` 로 업데이트하거나 데이터를 삭제합니다.
   - 장점: 구현이 단순합니다.
   - 단점: DB에 계속 쿼리를 날리므로 부하가 생길 수 있고, 실시간성이 조금 떨어집니다.
2. 트랜잭션 로그 테일링 (Transaction Log Tailing)
   - 방법: DB의 트랜잭션 로그를 감지하여, OUTBOX 테이블에 데이터가 추가되는 즉시 메시지 큐로 쏘는 방식입니다.
   - 도구: Debezium(디비지움) 같은 CDC(Change Data Capture) 도구를 주로 사용합니다.
   - 장점: 실시간성이 높고 애플리케이션 코드에 영향을 주지 않습니다.

## 4. 장점과 주의할 점

### 장점

- 데이터 일관성 보장: DB 업데이트와 메시지 발송 간의 원자성을 보장하여 “유령 데이터”나 “누락”을 방지합니다.
- 가용성: 메시지 브로커가 잠시 죽어있어도, DB에 메시지가 안전하게 저장되어 있으므로 나중에 다시 보내면 됩니다.

### 주의할 점

- 최소 한 번 전송
  - 릴레이가 메시지를 카프카에 보내고 나서, DB의 상태를 ‘완료’로 바꾸기 직전에 죽었다고 가정해 봅시다.
  - 릴레이가 다시 살아나면 DB에는 아직 ‘미발송’으로 되어 있으니 똑같은 메시지를 또 보냅니다.
  - 따라서 메시지를 받는 쪽(Consumer)은 반드시 중복 처리를 방지(멱등성)하도록 설계해야 합니다.

## 정리

트랜잭셔널 아웃박스 패턴은 분산 환경에서 “일단 DB 트랜잭션 안에서 ‘보낼 편지함(OUTBOX)’에 메시지를 같이 써놓고, 나중에 비동기로 꺼내 보내는 방식”입니다. 이를 통해 서비스 간 데이터 불일치를 막습니다.
