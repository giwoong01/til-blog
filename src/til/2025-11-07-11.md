---
title: 로그와 메트릭을 설명해주세요.
description: 로그와 메트릭 그리고 트레이스 무엇인가요?
date: 2025-11-07
tags: [로그, 메트릭, 트레이스]
---

# 로그

로그는 시스템이 작동하는 동안 발생하는 모든 이벤트에 대한 시계열 기록입니다. 문제가 발생했을 때 “왜?”라는 질문에 답하기 위한 가장 상세한 자료입니다.

- 비유: ‘일기장’, ‘선박의 항해 일지’
  - 10:01:05 - 사용자 A가 로그인했습니다.
  - 10:01:06 - API 요청을 받았습니다. GET /users/1
  - 10:01:07 - 오류 발생: NullPointerException (UserService.java:52)
- 데이터 형태
  - 텍스트 기반
  - 비정형: ERROR: Failed to connect to DB.
  - 정형: (일반적으로 JSON 형식) {"timestamp": "...", "level": "ERROR", "trace_id": "...", "message": "Failed to connect to DB"}
- 주요 목적
  - 디버깅: 오류가 발생한 정확한 지점과 컨텍스트를 파악합니다.
  - 근본 원인 분석: 특정 이벤트가 발생하기 직전과 직후의 상황을 재구성합니다.
  - 감사: “누가”, “언제”, “무엇을”했는지 보안 및 규정 준수를 위해 추적합니다.
- 단점
  - 데이터의 양이 방대하여 저장 비용이 비쌉니다.
  - 텍스트 기반이므로 수치적인 트렌드를 분석하거나 집계하기 어렵습니다.

# 메트릭

메트릭은 일정 시간 간격으로 시스템의 특정 수치를 측정한 값입니다. 시스템의 전반적인 건강 상태와 성능을 한눈에 파악하기 위해 사용됩니다.

- 비유: “자동차 계기판”
  - 현재 속도: 80km/h
  - 엔진 온도: 90도씨
  - 남은 연로: 60%
- 데이터 형태
  - 숫자와 키-벨류 태그의 조합
  - http_requests_total {method=”GET”, path=”/api/users”} = 1050 (Counter)
  - cpu_usage {core=”1”, mode=”system”} = 0.85 (Fauge, 85%)
  - request_latency_ms {path=”/api/users”} = [avg: 120, p95: 300, p99: 800] (Histogram)
- 주요 목적
  - 모니터링 및 대시보드: 시스템의 현 상태를 시각화하여 한눈에 파악합니다.
  - 알림: “CPU 사용률이 5분간 90% 이상”과 같이 미리 정의된 임계치를 넘으면 경고를 보냅니다.
  - 트렌드 분석: 시간의 흐믈에 따른 리소스 사용량 변화를 분석합니다.
- 장점
  - 데이터가 숫자이므로 집계가 매우 쉽습니다.
  - 용량이 로그보다 훨씬 작고 저장 비용이 저렴합니다.

# 관련 개념: 트레이스

하나의 요청이 여러 서비스를 거치는 전체 여정을 시각화한 것입니다.

- 비유: 택배 배송 추적
  - 물류센터 → 허브 → 배송기사 → 고객
- 목적
  - 여러 서비스 중 어디서 병목 현상이 발생하는지 정확히 찾아냅니다.
  - Logs + Metrics + Traces 이 세 가지를 관측 가능성의 3요소라고 부릅니다.

# 관측 가능성이란?

시스템의 외부 출력만 보고도 내부 상태를 얼마나 잘 추론하고 이해할 수 있는가를 나타내는 시스템의 속성입니다.

쉽게 말해, 시스템이 고장 났을 때, 굳이 접속해서 코드를 열어보거나 디버깅하지 않아도, 밖에서 수집된 데이터(로그, 메트릭, 트레이스)만으로 왜 고장 났는지 파악할 수 있는 능력을 의미합니다.

## 3대 요소

1. 로그 - 무슨 일이?
   - 시스템에서 발생한 개별 이벤트의 상세 기록입니다.
   - 역할: 디버깅과 근본 원인 분석(RCA)을 위한 가장 상세한 증거를 제공합니다.
2. 메트릭 - 어떤 상태?
   - 일정 시간 간격으로 측정한 시스템의 수치 데이터입니다. (CPU, 메모리, 요청 수)
   - 역할: 시스템의 전반적인 건강 상태를 모니터링하고, 임계치 기반의 알림을 생성합니다.
3. 트레이스 - 어디서?
   1. 하나의 요청이 여러 서비스를 거치는 전체 여정을 추정한 것입니다.
   2. 역할: Service A → Service B → Service C 중에서 정확히 어느 구간에서 병목이 발생했는지 식별합니다.

## 3요소가 함게 문제를 해결하는 과정 (예시)

1. 메트릭 → 알림
   - Prometheus(메트릭 수집기)가 알림을 보냅니다.
   - [알림 내용]: “지난 5분간 /api/payment 엔드포인트의 p99 응답 속도가 3000ms를 초과함!”
2. 트레이스 → 병목 식별
   - 개발자가 알림을 받고 대시보드로 이동합니다.
   - 3000ms가 걸린 요청의 트레이스를 클릭합니다.
   - [트레이스 분석]
     - Gateway (20ms)
     - Service-Auth (50ms)
     - Service-Payment (2900ms) ← 식별
       - DB Query (100ms)
       - External-PG-Gateway-Call (2800ms) ← 범인!
3. 로그 → 근본 원인
   - 이제 Service-Payment의 로그를 확인하러 로그 수집기로 이동합니다.
   - 위 트레이스 ID와 동일한 ID를 가진 로그를 검색합니다.
   - [로그 내용]: ERROR: Connection timeout whie calling ‘https://pg.example.com/pay’. Retrying (2/3)…
   - [최종 결론]: 외부 PG사 결제 연동 API가 응답하지 않아 타임아웃이 발생했고, 재시도 로직 때문에 전체 응답 시간이 3초나 걸렸구나.

메트릭(알림) → 트레이스(범위 축소) → 로그(원인 확정)로 자연스럽게 드릴 다운하며 미지의 문제를 신속하게 해결하는 능력을 의미합니다.
