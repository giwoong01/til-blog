---
title: 비관적 락의 공유 락과 배타 락
description: 비관적 락의 공유 락과 배타 락은 무엇일까요?
date: 2025-11-19
tags: [비관적 락, 공유 락, 배타 락]
---

## 공유락과 배타락

공유 락(Shared Lock)과 배타 락(Exclusive Lock)은 데이터베이스에서 동시성을 제어하기 위해 사용하는 비관적 락(Pessimistic Locking)의 핵심 메커니즘입니다.

두 락의 가장 근본적인 차이는 “자원에 대한 접근을 다른 트랜잭션과 공유할 수 있는가”에 있습니다.

- 공유 락 (S-Lock): “나 읽을 건데, 다른 사람도 읽는 건 괜찮아. 하지만 아무도 수정은 하지마.” (Read-Only, Shared)
- 배타 락 (X-Lock): “나 수정할 거니까, 아무도 읽지도 말고 수정도 하지마.” (Read-Write, Exclusive)

### 베타 락 (Exclusive Lock / X-Lock)

베타 락은 쓰기 락이라고도 합니다. (Write Lock)

- 목적
  - 데이터를 변경(INSERT, UPDATE, DELETE)하기 위해 획득하는 락입니다.
- 특징 (독점)
  - 한 트랜잭션이 특정 자원(e.g., Row 1)에 배타 락을 획득하면, 다른 어떤 트랜잭션도 해당 자원에 공유 락(읽기)도, 배타 락(쓰기)도 획득할 수 없습니다.
  - 모든 요청은 락이 해제될 때까지 대기(Blocking)합니다.
- SQL 구문 (명시적 획득)
  ```sql
  -- 트랜잭션 A
  SELECT * FROM accounts WHERE id = 1 FOR UPDATE;
  -- (id=1 로우에 X-Lock 획득)
  -- (다른 트랜잭션은 이 로우에 접근 불가)
  UPDATE accounts SET balance = 500 WHERE id = 1;
  COMMIT;
  -- (COMMIT 시 X-Lock 해제)
  ```
- 주요 용도
  - 데이터의 일관성이 깨지면 안되는 핵심적인 ‘수정’작업에 사용됩니다. (예: 재고 차감, 계좌 이체)

### 공유 락 (Shared Lock / S-Lock)

공유 락은 읽기 락이라고도 합니다. (Read Lock)

- 목적
  - 데이터를 조회하되, 조회하는 동안 다른 트랜잭션에 의해 변경되는 것을 막고 싶을 때 획득하는 락입니다. (MVCC의 스냅샷 읽기와는 다릅니다.)
- 특징 (공유)
  - 한 트랜잭션이 특정 자원(e.g., Row 1)에 공유 락을 획득해도, 다른 트랜잭션이 똑같이 공유 락(읽기)을 획득하는 것이 허용됩니다. → 내가 S-Lock을 들고 있을 때, 다른 사람도 S-Lock 획득 가능
  - 하지만 어떤 트랜잭션이든 해당 자원에 배타 락(쓰기)을 획득하려고 시도하면, 모든 공유 락이 해제될 때까지 대기해야 합니다.
- SQL 구문 (명시적 획득)
  ```sql
  -- MySQL (8.0+)
  SELECT * FROM accounts WHERE id = 1 FOR SHARE;

  -- MySQL (Older) / PostgreSQL
  SELECT * FROM accounts WHERE id = 1 LOCK IN SHARE MODE;
  ```
- 주요 용도
  - 특정 데이터를 읽고, 그 데이터를 기반으로 다른 작업을 수행할 때, 첫 번째 읽은 데이터가 중간에 변경되지 않아야 함을 보장할 때 사용됩니다. (마감 보고서 작성 시 특정 시점의 잔액 고정)

### 언제 사용되나요?

1. 트랜잭션 격리 수준 (Implicit)
   - 가장 높은 격리 수준인 SERIALIZABLE에서는, SELECT만 해도 DB가 자동으로 공유 락(S-Lock)을 획득하고 UPDATE 시에는 베타 락(X-Lock)을 획득하여 완벽한 격리를 구현합니다.
2. 비관적 락 (Explicit)
   - READ COMMITED나 REPEATABLE READ 수준에서는 기본적으로 (MVCC를 통해) 락 없이 읽기를 수행합니다.
   - 하지만 개발자가 “이 데이터는 내가 수정할 거니까 찜해야겠다” 또는 “읽는 동안 절대 바뀌면 안된다”라고 판단할 때, FOR UPDATE (X-Lock)나 FOR SHARE(S-LOCK)를 수동으로 사용하여 비관적 락을 구현합니다.

이러한 락들은 동시성을 제어하는 강력한 도구이지만, 잘못 사용하면 스레드들이 서로를 기다리는 데드락(Deadlock, 교착 상태)을 유발할 수 있습니다.

## 데드락(Deadlock, 교착 상태)이란?

데드락이란, 두 개 이상의 트랜잭션이 서로가 점유한 리소스(락)를 획득하기 위해 무한정 대기하는 상태를 말합니다.

두 트랜잭션이 원형으로 서로를 기다리게 되어, 양쪽 모두 영원히 다음 단계로 진행할 수 없게 되는 상황입니다.

### 데이터베이스 실제 발생 시나리오

DB 트랜잭션으로 살펴보겠습니다. accounts 테이블에 id = 1 (A계좌), id = 2 (B계좌) 두 개의 로우(Row)가 있다고 가정합니다.

- 시나리오: A계좌와 B계좌가 서로에게 돈을 이체하려고 동시에 시도합니다. (두 트랜잭션 모두 두 개의 로우에 배타 락(X-Lock)이 필요합니다.)

| **시간** | **트랜잭션 A (A → B 이체)**                   | **트랜잭션 B (B → A 이체)**                   | **상태**                                                         |
| -------- | --------------------------------------------- | --------------------------------------------- | ---------------------------------------------------------------- |
| **T1**   | `START TRANSACTION;`                          | `START TRANSACTION;`                          |                                                                  |
| **T2**   | `UPDATE accounts SET balance=... WHERE id=1;` |                                               | A가 **로우 1**에 **X-Lock** 획득                                 |
| **T3**   |                                               | `UPDATE accounts SET balance=... WHERE id=2;` | B가 **로우 2**에 **X-Lock** 획득                                 |
| **T4**   | `UPDATE accounts SET balance=... WHERE id=2;` |                                               | A가 **로우 2**의 X-Lock을 획득 시도 ➡️ **대기** (B가 락 보유 중) |
| **T5**   |                                               | `UPDATE accounts SET balance=... WHERE id=1;` | B가 **로우 1**의 X-Lock을 획득 시도 ➡️ **대기** (A가 락 보유 중) |

결과: 데드락 발생

- 트랜잭션 A는 로우 1을 잠근 채, 로우 2의 락(B가 보유)을 기다립니다.
- 트랜잭션 B는 로우 2를 잠근 채, 로우 1의 락(A가 보유)을 기다립니다.

A는 B를, B는 A를 기다리는 순환 대기가 발생하여 두 트랜잭션 모두 영원히 끝나지 않습니다.

### 데드락은 어떻게 해결되는가?

데이터베이스가 이런 바보 같은 상황을 무한정 방치하지 않습니다.

1. 데드락 감지: DBMS는 내부적으로 ‘데드락 감지기’를 실행하여, 일정 주기마다 트랜잭션 간의 락 대기 상태를 모니터링하고 순환 대기(데드락)이 발생했는지 감지합니다.
2. 희생양 선택: 데드락이 감지되면, DBMS는 두 트랜잭션 중 하나를 강제로 종료시킬 ‘희생양’으로 선택합니다. (보통 롤백 비용이 가장 적은 트랜잭션, e.g., 변경량이 적거나 오래되지 않은 트랜잭션)
3. 강제 롤백: DBMS는 ‘희생양’이 된 트랜잭션을 강제로 롤백 시킵니다.
4. 락 해제 및 재개: 트랜잭션 B가 롤백되면서 보유했던 모든 락(로우 2의 X-Lock)이 해제됩니다.
5. 이 락을 기다리던 트랜잭션 A는 비로소 로우 2의 락을 획득하여 작업을 마저 수행하고 커밋할 수 있게됩니다.

이때 롤백된 ‘희생양’ 트랜잭션을 실행했던 애플리케이션은 “데드락으로 인해 트랜잭션이 롤백되었습니다”라는 오류를 받게 되며, 일반적으로 이 트랜잭션을 처음부터 다시 시도 해야합니다.

### 데드락을 예방하는 개발자 습관!!

데드락은 DBMS가 해결해 주지만, 롤백과 재시도는 모두 비용입니다. 개발자는 데드락 발생 확률 자체를 낮추기 위해 노력해야 합니다.

1. 락 순서 일관성 (가장 중요)
   - 데드락의 핵심 원인은 리소스 획득 순서가 꼬이는 것입니다.
   - 애플리케이션 내의 모든 트랜잭션이 리소스에 접근하는 순서를 항상 동일하게 맞춥니다.
   - 예: A계좌와 B계좌를 다룰 땐, 무조건 id가 작은 순서대로 (로우1 → 로우2) 락을 걸도록 규칙을 정합니다.
   - 이렇게 하면 위 시나리오 T3에서 B는 로우 2가 아닌 로우 1을 먼저 잠그려다 A에 의해 대기 하게 되고, 데드락이 아닌 단순 블로킹(대기)으로 상황이 종료됩니다.
2. 트랜잭션은 가능한 짧게 유지
   - 트랜잭션이 락을 보유하는 시간이 길어질수록 다른 트랜잭션과 충돌(데드락 포함)할 확률이 기하급수적으로 높아집니다.
   - 트랜잭션 내에서 불필요한 비즈니스 로직, 외부 API 호출 등을 제거하고, DB 작업만 최소한으로 남겨 빠르게 커밋합니다.
3. 불필요하게 높은 격리 수준 사용 지양
   - 격리 수준이 SERIALIZABLE 처럼 높아질수록 락을 더 많이, 더 오래 유지하게 되어 데드락 가능성이 높아집니다. READ COMMITED나 (MySQL 기본 값인) REPEATABEL READ 수준을 우선적으로 고려합니다.
4. 적절한 인덱스 사용
   - 인덱스가 없어 Full Table Scan이 발생하면, 의도치 않게 테이블 전체에 락이 걸리거나 필요 없는 로우까지 락이 걸릴 수 있습니다. 인덱스를 통해 락의 범위를 최소한으로 줄여야 합니다.
