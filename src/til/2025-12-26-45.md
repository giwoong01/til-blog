---
title: 프로세스보다 스레드의 컨텍스트 스위칭이 더 빠른 이유
description:
date: 2025-12-26
tags: [프로세스, 스레드, 컨텍스트 스위칭]
---

핵심적인 이유는 스레드는 메모리 영역을 공유하기 때문입니다.

메모리 주소 공간의 전환 비용과 TLB(Translation Lookaside Buffer) 캐시의 효율성 차이입니다.

## 1. 메모리 주소 공간 공유 (Memory Sharing)

- 프로세스: 각 프로세스는 독립된 가상 메모리 공간을 가집니다. 따라서 컨텍스트 스위칭이 발생하면 가상 메모리 주소 체계 자체를 변경해야 합니다. (Page Table 교체). 이는 CPU 입장에서 매우 무거운 작업입니다.
- 스레드: 같은 프로세스 내의 스레드들은 Code, Data, Heap 영역을 공유합니다. 스위칭 시 이 영역은 그대로 두고, 각 스레드의 고유 영역인 Stack과 레지스터 값만 교체하면 됩니다.

## 2. 캐시 메모리 효율 (TLB Flush 문제)

이것이 성능 차이를 만드는 가장 큰 원인입니다.

- 프로세스 스위칭: 메모리 주소 체계가 바뀌기 때문에, CPU가 가상 주소를 실제 주소로 빠르게 변환하기 위해 사용하는 캐시인 TLB를 싹 비워야(Flush) 합니다.
- 스레드 스위칭: 메모리 공간이 같으므로 TLB를 비울 필요가 없습니다. 따라서 스위칭 직후에도 캐시 적중률이 유지되어 성능 저하가 거의 없습니다.

## 3. 저장/복구할 정보의 양 (Context Overhead)

- 프로세스: PCB(Process Control Block)에 저장해야 할 정보가 많습니다. CPU 레지스터뿐만 아니라 메모리 맵, 열린 파일 목록, 권한 정보 등 모두 관리해야 합니다.
- 스레드: TCB(Thread Control Block)는 가볍습니다. 주로 CPU 레지스터 상태만 저장하고 복구하면 됩니다.

## 정리

- 프로세스 스위칭
  - 메모리 공간을 통째로 옮겨야 합니다. TLB 초기화, 주소 변경. 시간이 오래걸립니다.
- 스레드 스위칭
  - 같은 메모리 공간에 Stack에서 나와 다른 Stack으로 가는 것입니다. Heap과 Data은 공유하므로 그대로 쓰면 됩니다. 매우 빠릅니다.
