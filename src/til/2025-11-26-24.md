---
title: HTTP 메소드에서 멱등성
description: HTTP 메소드에서 멱등성이란?
date: 2025-11-26
tags: [HTTP, 멱등성]
---

HTTP 메소드에서 멱등성(Idempotency)이란, “동일한 요청을 한 번 보내는 것과 여러 번 연속으로 보내는 것이 서버에 미치는 영향(부수 효과, Side Effect)이 동일하다”는 성질을 의미합니다.

수학적인 정의 (f(f(x)) = f(x))에서 빌려온 개념으로, 쉽게 말해 “몇 번을 반복해서 실행해도 결과적인 서버의 상태가 똑같다면 멱등하다”고 합니다.

이 개념은 네트워크 통신에서 안전한 재시도를 결정짓는 매우 중요한 기준이 됩니다.

## HTTP 메소드별 멱등성 분석

### 멱등한 메소드 (Idempotent)

1. GET / HEAD / OPTIONS (Safe & Idempotent)
   - 동작: 데이터를 조회만 합니다.
   - 이유: 1번 조회하든 100번 조회하든 서버의 데이터는 변하지 않습니다. (애초에 상태를 변경하지 않으므로 멱등합니다.)
2. PUT (Idempotent)
   - 동작: 리소스를 대체합니다. (없으면 생성, 있으면 덮어쓰기)
   - 예시: `PUT /users/1 { “age” : 20 }`
   - 이유: 이 요청을 10번 보내도, 1번 유저의 나이는 여전히 20입니다. 최종적인 DB 상태가 동일합니다.
3. DELETE (Idempotent)
   - 동작: 리소스를 삭제합니다.
   - 예시: `DELETE /users/1`
   - 이유
     - 첫 번째 요청: 삭제 성공 (200 OK). 리소스가 사라짐.
     - 두 번째 요청: 이미 삭제됨 (404 Not Found). 리소스가 여전히 없음.
     - 주의: 응답 코드는 200에서 404로 달라질 수 있지만, “서버에 해당 데이터가 없다”는 최종 상태는 동일하므로 멱등합니다.

### 멱등하지 않은 메소드 (Non-Idempotent)

1. POST (Non-Idempotent)
   - 동작: 요청된 데이터를 처리합니다. (주로 등록/추가에 사용)
   - 예시: `POST /orders { ”item”: “pizza” }`
   - 이유
     - 첫 번째 요청: 주문번호 1번 생성.
     - 두 번째 요청: 주문번호 2번 생성. (중복 주문 발생)
   - 서버의 상태가 요청 횟수만큼 변하므로 멱등하지 않습니다.
2. PATCH (Non-Idempotent)
   - 동작: 리소스를 부분 수정합니다.
   - 이유: 구현 방식에 따라 다릅니다.
     - `{ “age”: 20 }` 으로 값을 지정하면 멱등합니다.
     - 하지만 `{ “operation”: “add”, “value”: 1 }` 처럼 기존 값에 1을 더해라라는 명령일 경우, 호출할 때마다 값이 증가하므로 멱등하지 않습니다. 기본적으로는 멱등하지 않다고 간주합니다.

## 멱등성이 왜 중요할까요?

멱등성은 “네트워크 장애 시 재시도를 해도 되는가?”를 판단하는 핵심 근거입니다.

상황: 결제 요청을 보냈는데 응답이 안옴 (Timeout)

- POST (결제 승인 요청) 사용 시
  - 내 요청이 서버에 도달해서 결제가 됐는데 응답만 못 받은 건지, 아예 서버에 도달조차 못한 건지 알 수 없습니다.
  - 이때 무턱대고 재시도를 하면 중복 결제가 발생할 수 있습니다. (멱등하지 않기 때문)
  - 해결책: 클라이언트가 유니크한 requestId를 같이 보내서 서버가 중복을 막도록 별도 구현해야 합니다.
- PUT (회원 정보 수정) 사용 시
  - 응답이 안 오면 그냥 다시 보내도 됩니다.
  - 어차피 결과는 똑같기 때문입니다. 시스템이 훨씬 안정적으로 동작합니다.

## 멱등성 키

### 멱등성 키 (Idempotency Key) 패턴

앞서 설명했듯이 POST는 멱등하지 않습니다. 그렇다면 주문이나 결제 같이 POST를 써야 하는 중요한 요청이 타임아웃 났을 때, 어떻게 안전하게 재시도할까요?

이때 사용하는 것이 멱등서 키 전략입니다. API 호출을 논리적으로 멱등하게 만드는 기술입니다.

- 동작 원리
  1. 클라이언트: 요청을 보낼 때, 유니크한 키(UUID 등)를 생성해서 헤더에 담아 보냅니다. (예: Idempotency-Key: “unique-uuid-12”)
  2. 서버: 요청을 받으면 이 키를 DB(또는 Redis)에 저장해 둡니다.
  3. 시나리오:
     - 첫 요청: 키가 DB에 없으므로 정상 처리하고 결과를 저장합니다.
     - 재시도 요청 (중복): 똑같은 키(unique-uuid-123)로 요청이 오면, “아, 이거 아까 처리했던 거네?”라고 인지합니다.
     - 처리: 로직을 다시 실행하지 않고, 저장해뒀던 ‘첫 번째 성공 응답’을 그대로 반환합니다.
- 결과: POST 메소드임에도 불구하고, 시스템적으로 멱등성을 보장하게 됩니다.

### 안정성과 멱등성의 구분

HTTP 스펙에는 멱등성 말고도 안전성이라는 개념이 있습니다. 둘은 비슷해 보이지만 다릅니다.

- 안전함: 호출해도 서버의 상태(리소스)를 변경하지 않는가? (Read-Only)
- 멱등함: 여러 번 호출해도 결과가 동일한가?

PUT과 DELETE는 멱등하지만, 데이터를 변경하므로 안전하지는 않습니다.

### 멱등성은 약속이지 강제가 아니다.

이것이 개발자가 가장 주의해야 할 부분입니다. HTTP 메소드의 멱등성은 스펙상의 약속일 뿐, 프로토콜 레벨에서 강제되는 기능이 아닙니다.

- 잘못된 구현의 예:
  - 개발자가 `GET /danger-delete?id=1` 이라는 API를 만들고, 내부적으로 데이터를 삭제하도록 짰습니다.
  - 이 API는 GET 메소드를 썼지만 안전하지도 않고, 멱등하지도 않게 동작할 수 있습니다.
- 개발자의 책임
  - “PUT을 썼으니까 알아서 멱등하겠지?” 라고 생각하면 안됩니다.
  - PUT 요청을 받았을 때 `UPDATE count = count + 1` 쿼리를 실행하도록 코드를 짜면, 그 API는 껍데기만 PUT일 뿐 멱등성이 깨진 API가 됩니다.
  - 따라서 API를 설계하고 구현하는 개발자가 이 규약을 이해하고, 스펙에 맞게 동작하도록 코드를 작성해야 할 책임이 있습니다.
