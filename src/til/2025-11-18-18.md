---
title: 동기와 비동기
description: 동기와 비동기의 차이점은?
date: 2025-11-18
tags: [동기, 비동기]
---

동기와 비동기의 가장 핵심적인 차이는 “호출된 함수의 작업 완료를 호출한 함수가 기다리는가(Blocking)”입니다.

이는 프로그램의 제어권과 작업의 순서에 대한 문제입니다.

- 동기(Synchronous): 순서대로
  - 함수 A가 함수 B를 호출하면, B의 작업이 끝날 때까지 함수 A는 멈춥니다.(Blocked)
  - B의 결과를 받아야만 A가 다음 작업을 시작할 수 있습니다.
- 비동기(Asynchronous): 일단 맡기고
  - 함수 A가 함수 B를 호출하면, B의 작업이 끝나길 기다리지 않고 A는 즉시 다음 작업을 시작합니다. (Non-Blocked)
  - B는 별도의 스레드나 이벤트 루프에서 작업을 수행하고, 작업이 완료되면 콜백이나 다른 방식을 통해 A에게 결과를 알립니다.

![image.png](/images/til/2025-11-18-18/1.png)

## 제어권과 흐름

### 동기 (Synchronous)

동기 호출에서 제어권은 호출된 함수(B)에게 넘어갑니다.

- 흐름
  1. Main Thread가 functionA()를 실행합니다.
  2. functionA()가 functionB()를 호출합니다.
  3. functionA()는 functionB()가 리턴할 때까지 멈춥니다(Blocked). 제어권이 functionB()로 넘어갑니다.
  4. functionB()의 실행이 완료되어 결과가 리턴됩니다.
  5. 제어권이 functionA()로 돌아오고, functionA()가 다시 실행됩니다.
- 예시: String data = restTemplate.getForObject(…)
  - 이 코드는 restTemplate 이 외부 API로부터 data를 받아올 때까지 현재 스레드를 완전히 멈춥니다.
- 문제점: 외부 서비스가 10초 걸리면, 내 스레드도 10초간 멈춥니다. 이런 요청이 100개 쌓이면 (예: 톰캣 스레드 풀 100개) 서비스 전체가 마비됩니다. (서킷 브레이커가 필요한 이유)

### 비동기

비동기 호출에서 제어권은 호출 즉시 호출자에게 다시 돌아옵니다.

- 흐름
  1. Main Thread가 functionA()를 실행합니다.
  2. functionA()가 functionB()를 호출합니다.
  3. functionB()는 작업을 별도의 스레드(Worker Thread)나 이벤트 루프에 위임하고, “작업 시작했습니다”라는 의미의 객체를 즉시 리턴합니다.
  4. functionA()는 멈추지 않고 (Non-Blocked) 즉시 다음 코드를 실행합니다.
  5. 별도 스레드에서 functionB()의 작업이 완료되면, 등록된 콜백 함수를 실행하여 결과를 전달합니다.
- 예시: CompletableFuture<String> data = webClient.get()…
  - 이 코드는 즉시 CompletableFuture(미래에 완료될 것이라는 약속) 객체를 반환하고, Main Thread는 다음 작업을 계속합니다.
  - 실제 HTTP 요청은 별도의 스레드 풀에서 실행됩니다.
- 장점: 스레드를 낭비하지 않으므로(Non-Blocking I/O), 적은 수의 스레드로도 대량의 동시 요청을 처리할 수 있습니다. (성능 및 확장성)

## Blocking vs Non-Blocking

동기/비동기는 “작업 순서와 완료 여부에 대한 관심”의 관점이고, 블로킹/논블로킹은 “제어권”의 관점입니다.

이 둘은 자주 같이 쓰이지만 엄밀히는 다릅니다.

1. Synchronous + Blocking (동기 - 블로킹)
   - 가장 일반적인 동기 모델
   - 호출자가 Blocked 되고, 작업 완료도 순차적으로 받습니다.
2. Asynchronous + Non-Blocking (비동기 - 논블로킹)
   - 가장 일반적인 비동기 모델
   - 호출자가 Non-Blocked되고, 작업 완료는 나중에 콜백으로 받습니다.
3. Synchronous + Non-Blocking (동기 - 논블로킹)
   - 호출자가 Non-Blocked 되지만(A는 계속 실행), 작업 완료는 순차적으로 기다립니다.
   - A와 B가 호출하고 바로 다음 일을 합니다. 하지만 A는 B의 결과가 필요해서, “B 끝났어?”라고 주기적으로 계속 물어봅니다(Polling). B가 “끝났어”라고 할 때까지 A는 다른 일을 하다가도 계속 B를 확인해야 합니다. (비효율적)
4. Asynchronous + Blocking (비동기 - 블로킹)
   - B에게 비동기로 작업을 시켰지만 (A가 B의 완료를 신경 쓰지 않음), A가 그 결과를 받을 때까지 Blocked되는 모순적인 조합
   - 예: future.get()을 호출하는 순간. 비동기로 시작했지만, get() 이 결과를 가져올 때까지 Main Thread는 멈춥니다.
