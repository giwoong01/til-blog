---
title: TCP 3-way handshake
description: TCP 3-way handshake란 무엇인가
date: 2025-11-17
tags: [TCP]
---

TCP 3-way handshake는 신뢰할 수 있는 TCP 연결을 시작하기 위해 양쪽(클라이언트와 서버)이 서버 통신할 준비가 되었는지 확인하는 3단계의 표준 절차입니다.

이 과정의 핵심 목적은 두 장치가 모두 데이터를 보낼 준비가 되었고, 받을 준비도 되었으며, 서로의 존재를 인지했음을 보장하는 것입니다.

가장 쉬운 비유는 전화 통화 입니다.

1. 나 (Client): 여보세요? (SYN)
2. 상대방 (Server): 네 여보세요, 당신 목소리 들려요. 제 목소리 들리나요? (SYN + ACK)
3. 나 (Client): 네, 당신 목소리도 잘 들려요. (ACK)

이 3단계가 끝나야 비로소 두 사람은 “아 이제 연결이 확실히 됐구나”라고 확신하고 본론을 시작할 수 있습니다.

## TCP 3-way Handshake의 3단계

이 과정에서는 SYN과 ACK라는 TCP 헤더의 제어 플래그(Flag)가 사용됩니다.

- SYN: “연결을 시작하고 싶습니다. 제 ‘대화 순서 번호’는 J입니다.”
- ACK: “당신의 메시지를 잘 받았습니다. 제가 기대하는 당신의 다음 ‘대화 순서 번호’는 X+1입니다.”

### 1단계: Client → Server (SYN)

- 클라이언트: “서버야, 나랑 연결할래?”
- 동작: 클라이언트는 서버에 접속을 요청하는 SYN 패킷을 보냅니다.
- 기술 상세
  - SYN 플래그가 1로 설정됩니다.
  - 클라이언트는 ‘초기 순서 번호’를 무작위로 생성하여 Sequence Number 필드에 담아 보냅니다. (예: Seq = J)

### 2단계: Server → Client (SYN + ACK)

- 서버: “그래 좋아. 네 요청 받았어. 나도 준비됐어.”
- 동작: 서버는 클라이언트의 SYN 요청을 받고, 자신도 연결할 준비가 되었음을 알리는 SYN 패킷과 요청을 잘 받았다는 ACK 패킷을 동시에 보냅니다.
- 기술 상세
  - SYN 플래그가 1로, ACK 플래그가 1로 설정됩니다.
  - 서버도 자신만의 ‘초기 순서 번호’를 생성하여 Sequence Number 필드에 담아 보냅니다. (예: Seq = K)
  - Acknowledgement Number 필드에는 “당신의 다음 순서 번호는 J+1이길 기대한다”는 의미로 클라이언트가 보낸 J에 1을 더한 값을 담아 보냅니다.(예: Ack = K + 1)

### 3단계: Client → Server (ACK)

- 클라이언트: “좋아, 네 응답도 잘 받았어. 이제 시작하자”
- 동작: 클라이언트는 서버의 SYN + ACK 응답을 받고, “서버도 준비된 것을 확인했다”는 의미로 최종 ACK 패킷을 보냅니다.
- 기술 상세:
  - ACK 플래그가 1로 설정됩니다.
  - 클라이언트는 Sequence Number 필드에 J+1을 담아 보냅니다. (예: Seq = J + 1)
  - Acknowledgement Number 필드에는 “당신의 다움 순서 번호는 K+1이길 기대한다”는 의미로 서버가 보낸 K에 1을 더한 값을 담아 보냅니다. (예: Ack = K + 1)

## 왜 3-way 인가요? (2-way가 아닌 이유)

2-way(Client가 SYN 보내고 Server가 SYN-ACK로 답함)로 끝내면 안될까요?

안됩니다. 3-way가 필요한 핵심 이유는 서버가 클라이언트의 ACK를 받아야만, 클라이언트가 서버의 응답을 확실히 받았다는 것을 서버가 알 수 있기 때문입니다.

만약 2-way로 연결된다고 가정해 봅시다.

1. (오래된 요청) 클라이언트가 SYN (J)을 보냈는데, 이게 네트워크에서 지연됩니다.
2. (새 요청) 클라이언트가 타임아웃으로 판단, 새 SYN을 보냅니다.
3. 서버가 SYN을 받고 SYN - ACK를 보냅니다.
4. 클라이언트가 ACK (K+1)를 보내고 정상 연결(연결1)이 됩니다.
5. …
6. (문제 발생) 네트워크에 갇혀 있던 1번의 오래된 SYN (J) 패킷이 뒤늦게 서버에 도착합니다.
7. 서버는 “아, 새 연결 요청이구나”라고 오해하고 SYN-ACK (K’, J+1)를 보냅니다.
8. 만약 2-way라면, 서버는 이 시점에 연결 2가 성립되었다고 착각하고 자원을 할당합니다.
9. 하지만 클라이언트는 이미 ‘연결1’을 사용 중이므로, 이 SYN-ACK (K’, J+1)를 무시합니다.
10. 결과: 서버는 클라이언트가 사용하지도 않을 유령 연결(연결2)에 불필요한 자원을 낭비하게 됩니다.

3-way handshake는 9번 단계에서 클라이언트가 서버에게 “네 응답(K’) 잘 받았다”는 ACK(K’+1)를 보내지 않기 때문에, 서버가 “아, 3단계 ACK가 안 오는걸 보니 이건 유령 연결이구나”라고 판단하고 ‘연결2’를 포기할 수 있게해줍니다.
