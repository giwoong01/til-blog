---
title: 분산 환경에서 Redis를 활용한 잠금
description: 분산 환경에서 Redis를 활용한 잠금은 어떻게 구현할 수 있나요?
date: 2026-02-16
tags: [분산 환경, Redis]
---

분산 환경에서 Redis를 활용해 잠금을 구현하는 것은 매우 일반적이고 효율적인 방법입니다. Redis는 싱글 쓰레드로 동작하여 명령어를 순차적으로 처리하기 때문에, 여러 서버에서 동시에 요청이 와도 원자성을 보장하기 쉽기 때문입니다.

구현의 핵심은 “내가 이 자원을 쓰고 있다는 표시(Key)를 남기고, 작업이 끝나면 지우는 것”입니다. 하지만 분산 환경이라 신경 써야 할 예외 상황들이 꽤 있습니다.

### 1. 기본 원리: SETNX

가장 기본적인 개념은 Redis의 SETNX 명령어를 사용하는 것입니다.

- 락 획득: “이 키(Key)가 없을 때만 값을 저장해라”
    - 성공(1): 락 획득
    - 실패(0): 이미 누군가 락을 잡고 있음
- 락 해제: “다 썼으니 키를 삭제해라 (DEL)”

하지만 단순히 SETNX와 DEL만 사용하면 두 가지 문제가 발생합니다.

## 2. 문제점

1. 락의 자동 만료 (Deadlock 방지)
    - 상황: 서버 A가 락을 잡고 작업을 하다가 갑자기 전원이 꺼져버렸습니다.
    - 문제: DEL 명령을 못 보냈기 때문에, 락이 영원히 남아있습니다. 다른 서버들은 영원히 기다려야 합니다.
    - 해결: 락을 잡을 때 유효 시간(TTL)을 반드시 설정해야 합니다.

1. 락의 소유권 확인 (오발탄 방지)
    - 상황
        1. 서버 A가 락(TTL 10초)을 획득했습니다.
        2. A의 작업이 길어져서 15초가 걸렸습니다. (이미 10초에 락은 자동으로 만료됩니다.)
        3. 서버 B가 락이 빈 것을 보고 새로 획득했습니다.
        4. 뒤늦게 작업을 마친 A가 DEL을 날려서 B의 락을 지워버립니다.
    - 해결: 락을 지울 때 “내가 만든 락이 맞는지” 값을 확인하고 지워야 합니다. 이를 위해 락의 값에 랜덤한 고유 ID를 넣습니다.

## 3. 명령어 구현

### 1단계: 원자적인 락 구현

과거에는 SETNX 후 EXPIRE를 따로 보냈지만, 그 사이에 서버가 죽으면 TTL이 안 걸리는 문제가 있었습니다. 최신 Redis에서는 SET 명령어 하나로 처리합니다.

```bash
# 사용법: SET key value NX PX milliseconds
SET lock:order:1234 "unique_session_id_A" NX PX 30000
```

- NX: 데이터가 없을 때만 저장 (Lock 역할)
- PX 30000: 30초 뒤에 자동 삭제 (Deadlock 방지)
- unique_session_id_A: 나중에 내가 건 락인지 확인하기 위한 식별자

### 2단계: 원자적인 락 해제 (Lua Script)

“값을 확인하고(GET) 일치하면 삭제(DEL)”하는 로직은 두 번의 통신이 필요하므로, 그 사이에 틈이 생길 수 있습니다. 이를 완벽하게 보호하기 위해 Lua Script를 사용하여 Redis 내부에서 한 번에 실행시킵니다.

```lua
-- KEYS[1]: lock key
-- ARGV[1]: unique_session_id
if redis.call("get", KEYS[1]) == ARGV[1] then
    return redis.call("del", KEYS[1])
else
    return 0
end
```

## 4. 실무 구현: Redisson 라이브러리

직접 Redis 명령어를 날리는 것은 번거롭고 실수하기 쉽습니다. Java 환경에서는 Redisson이라는 라이브러리를 사용하는 것이 표준입니다.

Redisson은 다음과 같은 기능을 제공합니다.

1. 스핀 락 방지 (Pub/Sub)
    - 락을 못 얻었을 때 계속 “됐어? 됐어?” 물어보는 대신, 락이 해제되면 알림을 받는 구조라 Redis 부하가 적습니다.
2. 워치독 (WatchDog)
    - 작업이 길어지면 락이 만료되지 않게 자동으로 TTL을 연장해 줍니다. (작업 도중 락이 풀리는 사고 방지)
3. 편리한 인터페이스
    1. Java의 `java.util.concurrent.locks.Lock` 인터페이스를 구현하여 사용법이 매우 직관적입니다.

```java
RLock lock = redissonClient.getLock("lock:order:1234");

try {
    // 10초 동안 락 획득 시도, 락 획득 후 1분간 점유
    boolean available = lock.tryLock(10, 60, TimeUnit.SECONDS);
    
    if (available) {
        // [중요 구간] 재고 감소 로직 수행
    }
} finally {
    if (lock.isLocked() && lock.isHeldByCurrentThread()) {
        lock.unlock(); // 안전하게 락 해제
    }
}
```

## 정리

분산 락을 Redis로 구현할 때는

1. 원자성: `SET … NX PX` 옵션을 사용하여 획득 시 원자성을 보장해야 합니다.
2. 고유성: 락의 Value에 고유 ID를 넣어 남의 락을 지우지 않게 해야 합니다.
3. 도구 사용: 직접 구현하기보다는 검증된 라이브러리인 Redisson을 사용하는 것이 정신 건강과 시스템 안정성에 좋습니다.