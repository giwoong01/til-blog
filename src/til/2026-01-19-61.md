---
title: JVM에서 GC 대상 객체를 판단하는 기준은 무엇인가요?
description:
date: 2026-01-19
tags: [JVM, GC]
---

JVM의 가비지 컬렉터(GC)가 어떤 객체를 쓰레기로 판단하여 수거할지 결정하는 핵심 기준은 도달 가능성(Reachability)입니다.

즉, “유효한 참조가 있는가?”가 아니라, “GC Root로부터 연결되어 도달할 수 있는가?”를 따지는 Reachability Analysis(도달성 분석) 알고리즘을 사용합니다.

## 1. 핵심 알고리즘: Reachability Analysis

JVM은 객체의 생존 여부를 판단하기 위해 그래프 탐색과 유사한 방식을 사용합니다.

- Reachable (도달 가능)
  - GC Root라고 불리는 시작점에서부터 참조 체인을 따라가서 도달할 수 있는 객체입니다. 이 객체들은 살아있는 객체로 간주되어 수거되지 않습니다.
- Unreachable (도달 불가능)
  - GC Root에서 어떤 경로를 통해서도 도달할 수 없는 객체입니다. 이들은 GC의 대상이 됩니다.

왜 “참조 횟수”를 안쓰나요? 단순 참조 횟수 계산 방식은 순환 참조 문제를 해결하지 못합니다. A와 B가 서로를 참조하고 있지만, 외부에서는 아무도 그 둘을 참조하지 않을 경우, 실제로는 쓰레기지만 참조 카운트가 0이 아니어서 수거되지 않는 메모리 누수가 발생합니다. Reachability Analysis는 루트에서 도달 못 하면 끊어버리므로 이 문제를 완벽히 해결합니다.

## 2. GC Root란 무엇인가?

“도달 가능한가”를 판단하는 시작점이 되는 대상들입니다. 주로 힙 영역 밖에서 힙 영역의 객체를 참조하고 있는 경우입니다.

대표적인 GC Root는 다음과 같습니다.

1. Stack의 로컬 변수 및 파라미터: 현재 실행 중인 메소드 안에서 사용되는 지역 변수나 매개변수가 참조하는 객체 (실행 중이니 당연히 회수하면 안 됨)
2. Method Area의 정적(Static) 변수: 클래스의 static 멤버 변수가 참조하는 객체. (프로그램 종료 시까지 살아있어야 함)
3. JNI (Native Method) 참조: 자바 코드가 아닌 C/C++ 등 네이티브 코드로 작성된 메소드에서 참조하는 객체
4. 상수(Constant): 메소드 영역의 상수 풀에서 참조하는 객체

## 3. 참조의 4가지 유형

“도달 가능하다”고 해서 무조건 안 지원지는 것은 아닙니다. Java는 개발자가 객체의 생명 주기를 더 섬세하게 제어할 수 있도록 4가지 참조 레벨을 제공합니다.

- Strong Reference (강한 참조)
  - `Object obj = new Object()` 와 같은 일반적인 참조
  - 절대 GC 되지 않음. 메모리가 부족하여 OOM 에러를 냄
- Soft Reference (소프트 참조)
  - `SoftReference<T>`
  - 강한 참조가 없고 Soft 참조만 남았을 때
  - 메모리가 부족할 때만(OOM 직전) GC 됨 (주로 캐싱에 사용)
- Weak Reference (약한 참조)
  - `WeakReference<T>`
  - 강한 참조가 없고 Weak 참조만 남았을 때
  - 다음 GC 실행 시 무조건 수거됨 (WeakHashMap 등에서 사용)
- Phantom Reference (팬텀 참조)
  - `PhantomReference<T>`
  - 객체 자체는 이미 수거되었고, 파이널라이즈 이후의 처리를 위해 사용됨
  - get()을 해도 항상 null을 반환하며, 큐를 통해 객체가 죽었음을 알 수 있음

## 정리

JVM은 GC Root(스택 변수, 스태틱 변수 등)에서 시작하여 참조의 끈을 따라가 봅니다.

- 끈이 닿으면 → 생존
- 끈이 닿지 않으면 → 수거 대상

이것이 자바 메모리 관리의 대원칙입니다.
