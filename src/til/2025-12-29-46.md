---
title: HTTP/1.1, HTTP/2.0
description: HTTP/1.1과 HTTP/2.0란 무엇인가요?
date: 2025-12-29
tags: [HTTP/1.1, HTTP/2.0]
---

HTTP/1.1과 HTTP/2.0은 웹 브라우저와 웹 서버가 통신하기 위한 프로토콜의 버전입니다.

가장 큰 차이점은 성능과 효율성입니다. HTTP/1.1이 가진 근본적인 속도 저하 문제를 해결하기 위해, Google의 SPDY 프로토콜을 기반으로 2015년에 HTTP/2.0이 등장했습니다.

## 1. HTTP/1.1: 텍스트 기반의 직렬 처리

1990년대 후반부터 웹을 지탱해온 표준이지만, 웹 페이지가 복잡해지면서 태생적인 한계를 드러냈습니다.

### 주요 특징 및 문제점

1. 텍스트 기반 (Text Protocol): 사람이 읽을 수 있는 텍스트 형태로 데이터를 전송합니다. 이는 가독성은 좋지만, 기계가 파싱하기에는 비효율적입니다.
2. HOL Blocking (Head of Line Blocking): 가장 치명적인 문제입니다.
   - HTTP/1.1은 기본적으로 요청을 순차적으로 처리합니다.
   - 앞선 요청이 처리가 늦어지면, 뒤에 있는 가벼운 요청들도 줄줄이 대기해야 합니다.
3. 무거운 헤더 구조
   - 매 요청마다 중복된 헤더 값을 계속 보냅니다.
   - 요청 본문보다 헤더가 큰 경우도 발생하여 대역폭을 낭비합니다.

## 2. HTTP/2.0: 바이너리 기반의 병렬 처리

HTTP/1.1의 성능 저하를 해결하여 지연 시간을 줄이는 것이 목표입니다.

### 핵심 기술 4가지

1. 멀티 플렉싱
   - 한 개의 TCP 연결 내에서 여러 개의 요청과 응답을 동시에 주고받습니다.
   - 요청 순서에 상관 없이 조각 단위로 쪼개서 보내고, 도착지에서 다시 조립합니다.
   - 이로써 HTTP/1.1의 HOL Blocking 문제를 해결합니다.
2. 바이너리 프레이밍
   - 텍스트가 아닌 바이너리(0과 1)로 데이터를 전송합니다.
   - 파싱 속도가 빠르고, 전송 중 오류 발생 가능성이 낮아졌습니다.
3. 헤더 압축
   - HPACK이라는 압축 방식을 사용하여 헤더의 크기를 획기적으로 줄였습니다.
   - 허프만 인코딩을 사용하며, 클라이언트와 서버가 헤더 테이블을 유지하여 이전에 보낸 헤더는 중복해서 보내지 않고 인덱스 값만 전송합니다.
4. 서버 푸시
   - 클라이언트가 요청하지 않은 리소스도 서버가 알아서 미리 보내줄 수 있습니다.
   - 예: 클라이언트가 index.html만 요청했는데, 서버가 “이거 렌더링하려면 style.css도 필요할걸?”이라며 CSS파일도 같이 보내줍니다.

## 참고

HTTP/2.0도 TCP 프로토콜 자체의 문제(TCP HOL Blocking)는 해결하지 못했습니다. 이를 해결하기 위해 최근에는 UDP 기반의 HTTP/3(QUIC)가 등장하여 점차 사용이 늘어나고 있습니다.
