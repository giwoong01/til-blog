---
title: 스레드, 프로세스, 코어의 수는 많을수록 좋을까요?
description:
date: 2025-11-21
tags: [스레드, 프로세스, 코어]
---

결론부터 말하면 무조건 많을수록 좋은 것은 아닙니다.

컴퓨터 공학에서 과유불급이 철저하게 적용되는 영역입니다. 하드웨어 리소스(코어)와 소프트웨어 리소스(프로세스, 스레드) 간의 균형이 깨지는 순간, 시스템 성능은 오히려 급격히 저하됩니다.

이 현상을 이해하기 위해서는 하드웨어적 한계와 소프트웨어적 비용이라는 두 가지 핵심 개념을 이해해야 합니다.

## 1. 코어 (Core): 하드웨어의 물리적 일꾼

코어는 실제 연산을 수행하는 CPU 내부의 물리적인 처리 단위입니다.

- 많으면 좋은 경우
  - 수행해야 할 작업이 서로 독립적이어서 병렬 처리가 가능한 경우입니다. (예: 동영상 렌더링, 대규모 데이터 분석, 머신러닝 학습)
- 많아도 소용 없는 경우
  - 프로그램의 실행 시간은 병렬화가 불가능한 순차적인 코드의 비중에 의해 결정됩니다.
  - 아무리 코어가 100개, 1000개가 있어도, 프로그램 로직상 반드시 순서대로 실행되어야 하는 부분이 50%라면, 전체 성능 향상은 최대 2배를 넘을 수 없습니다.
  - 또한, 코어가 많아질수록 코어 간의 통신 비용과 데이터 동기화(Locking) 비용이 증가하여 성능 향상 폭은 체감합니다.

## 2. 프로세스와 스레드: 소프트웨어의 논리적 작업 단위

프로세스와 스레드는 OS가 관리하는 작업의 단위입니다. 이들의 수가 코어 수보다 지나치게 많아지면 아래와 같은 부작용이 발생합니다.

### 문맥 교환 (Context Switching) 오버 헤드

이것이 가장 치명적인 비용입니다.

- 개념
  - CPU 코어는 한 번에 하나의 작업(스레드)만 처리할 수 있습니다. 코어 수보다 많은 스레드를 동시에 실행하는 것처럼 보이게 하려면, OS는 아주 짧은 시간 단위로 스레드를 번갈아 가며 실행해야 합니다. (시분할, Time-Slicing)
- 비용
  - 스레드 A에서 스레드 B로 넘어갈 때, CPU가 실제 유용한 작업을 하는 시간보다 작업을 교체하는 데 쓰는 시간(문맥 교환)이 더 길어지는 주객전도 현상이 발생합니다.
- 문제점
  - 스레드가 너무 많으면, CPU가 실제 유용한 작업을 하는 시간보다 작업을 교체하는 데 쓰는 시간이 더 길어지는 주객전도 현상이 발생합니다.

### 스레싱 (Thrashing)

- 프로세스가 너무 많아지면 메모리가 부족해집니다.
- OS는 부족한 메모리를 확보하기 위해 디스크의 스왑 영역을 사용하게 되는데, 디스크 I/O 속도는 메모리보다 현저히 느립니다.
- 결국 CPU는 데이터를 기다리느라 멈추게 되고, 시스템 전체가 멈춘 것처럼 버벅거리는 현상을 스레싱이라고 합니다.

## 최적의 개수는? (CPU-bound vs I/O-bound)

그렇다면 적절한 수는 얼마일까요? 이는 프로그램의 성격에 따라 결정됩니다.

### CPU 집중형 작업 (CPU-bound Task)

- 특징: 복잡한 수학 연산, 인코딩, 암호화폐 채굴 등 CPU가 쉴 새 없이 계산만 하는 작업
- 최적 스레드 수: 코어 수 + 1 (또는 코어 수와 동일)
- 이유: 코어가 이미 100% 가동 중이므로, 스레드를 더 만들어봤자 문맥 교환 비용만 발생하여 성능이 떨어집니다. (+1을 하는 이유는 혹시 모를 페이지 부재 등으로 스레드가 멈출 때를 대비한 예비용입니다.)

### I/O 집중형 작업 (I/O-bound Task)

- 특징: 웹 서버, 데이터베이스 쿼리 처리, 파일 읽기/쓰기 등. 대부분의 시간 동안 CPU가 계산하는 게 아니라 외부 응답(DB, 네트워크)을 기다리는(Waiting) 작업.
- 최적 스레드 수: 코어 수보다 훨씬 많아도 됨
- 이유: 스레드 A가 DB 응답을 기다리며 멍하니 있는(Block) 동안, CPU는 노는 대신 스레드 B로 넘어가서 일을 처리할 수 있기 때문입니다.
- 공식: 보통 코어 수 \* (1 + 대기 시간 / 작업 시간) 같은 공식을 사용하거나, 성능 테스트를 통해 적정 값을 튜닝합니다.

## 정리

1. 하드웨어 (코어): 많으면 잠재력은 커지지만, 소프트웨어가 병렬화를 지원해야 하며 비용 효율이 감소하는 지점이 존재합니다.
2. 소프트웨어 (프로세스/스레드): 무조건 많으면 문맥 교환 오버헤드 때문에 성능이 박살납니다.
3. 결론:
   - CPU를 많이 쓰는 작업이라면 스레드 수를 코어 수에 맞춰야 합니다.
   - 대기가 많은 작업(웹 서버 등) 이라면 스레드 수를 코어 수보다 늘려서 CPU 활용률을 극대화해야 합니다.
   - 결국 시스템의 성능은 문맥 교환 비용을 최소화하면서 CPU 가동률을 100%에 가깝게 유지하는 균형점을 찾는 데 달려 있습니다.
