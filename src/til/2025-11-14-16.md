---
title: 동기 방식으로 외부 서비스 호출
description: 동기 방식으로 외부 서비스를 호출할 때 외부 서비스 장애가 나면 어떻게 조치할 수 있나요?
date: 2025-11-14
tags: [Spring Boot, Java, 동기]
---

동기 방식으로 외부 서비스를 호출할 때 장애가 발생하면, 그 장애가 내부 서비스로 전파되어 결국 내 서비스까지 마비되는 것이 가장 치명적인 문제입니다.

호출한 스레드가 응답을 무한정 기다리게 되고, 이런 스레드가 쌓이면(톰캣 스레드 풀 고갈) 내 서비스는 더 이상 다른 어떤 요청도 처리할 수 없게 됩니다.

따라서 조치의 핵심은 장애를 격리하고 내 서비스를 보호하는 것입니다. 이를 위한 4가지 필수 전략이 있습니다.

## 4가지 전략

### 1. 타임아웃(Timeout) 설정 (필수 방어)

가장 기본적이고 필수적인 1차 방어입니다. “무한정 기다리지 않겠다”는 선언입니다.

- 동작: 외부 서비스가 정해진 시간 (예: 3초) 안에 응답하지 않으면, 내 서비스가 먼저 연결을 끊고 즉시 실패로 처리합니다.
- 이유: 이 설정이 없으면, 외부 서비스가 10분 동안 응답이 없을 때 내 서비스의 스레드도 10분 동안 대기 상태로 묶여있게 됩니다.
- 적용: RestTemplate, WebClient 등 모든 HTTP 클라이언트 라이브러리에는 Connection Timeout과 Read Timeout 설정이 존재합니다.

```java
// 예시: RestTemplateBuilder를 사용한 타임아웃 설정
@Bean
public RestTemplate restTemplate() {
    return new RestTemplateBuilder()
            .connectTimeout(Duration.ofSeconds(2)) // 연결 시도 시간 (2초)
            .readTimeout(Duration.ofSeconds(3))    // 데이터 응답 대기 시간 (3초)
            .build();
}
```

### 2. 재시도 패턴

타임아웃이 발생했거나 5xx 에러 (서버 일시 장애)를 받았을 때, “일시적인 네트워크 오류일 수도 있으니 몇 번 더 시도해 보자”는 전략입니다.

- 동작: 실패 시 즉시 에러로 처리하지 않고, 정해진 횟수(예: 3회)만큼, 일정한 간격(예: 1초 후)을 두고 재호출합니다.
- 이유: 어쩌다 한 번 발생하는 일시적인 네트워크 불안정이나 외부 서비스의 순간적인 재시작 등에 대응할 수 있습니다.
- 적용: spring-retry 라이브러리의 @Retryable 어노테이션을 사용하는 것이 가장 편합니다.

```java
@Service
public class ExternalApiService {

    // 5xx 에러나 TimeoutException 발생 시 최대 3번, 1초 간격으로 재시도
    @Retryable(
        value = { FeignException.ServiceUnavailable.class, TimeoutException.class },
        maxAttempts = 3,
        backoff = @Backoff(delay = 1000)
    )
    public String callExternalApi() {
        // ... 외부 서비스 호출 로직 ...
    }
}
```

- 주의: 4xx 에러는 재시도하면 안 됩니다. 요청 자체가 잘못된 것이므로 재시도해도 무조건 실패합니다.

### 3. 서킷 브레이커 패턴 (핵심)

재시도로도 해결이 안 되고 실패가 지속적으로 누적될 때, 내 서비스를 보호하기 위한 가장 강력한 전략입니다.

- 동작:
  1. Closed (닫힘 - 평상시): 요청을 정상적으로 전달합니다. 실패가 일정 비율 이상 누적되면 차단기를 내립니다.
  2. Open (열림 - 장애 상태): 차단기가 내려간 상태. 더 이상 외부 서비스를 호출하지 않고 즉시 실패응답을 반환합니다. 이로써 내 서비스의 스레드가 묶이는 것을 원천 차단하고, 장애가 난 외부 서비스가 복구할 시간을 벌어줍니다.
  3. Half-Open (반-열림): 일정 시간(예: 1분)이 지나면, 차단기가 반쯤 열린 상태가 됩니다. 테스트 요청을 한 번 보내보고, 이 요청이 성공하면 Closed로, 실패하면 다시 Open 상태로 돌아갑니다.
- 적용: Resilience4j (Hystrix의 후속) 라이브러리가 Spring Boot 생태계의 표준입니다.

### 4. 폴백 처리

위의 재시도가 모두 실패했거나, 서킷 브레이커가 Open 상태일 때 “대신 무엇을 할 것인가?”에 대한 계획입니다.

- 동작: 실제 서비스 호출 대신, 미리 준비된 대안 로직을 실행합니다.
- 이유: 사용자에게 무작정 “500 Internal Server Error”를 보여주는 것이 아니라, 더 나은 사용자 경험을 제공하기 위함입니다.
- 예시:
  - 기본 값 반환: `return new Product(”기본 상품”, 0);` 또는 `return Collections.emptyList();`
  - 캐시된 데이터 반환: `“현재 실시간 정보 조회가 어렵습니다. 어제 자 데이터를 기준으로 표시합니다.”`
  - 명확한 에러 메시지 반환: `return “현재 xx페이 점검 중입니다. 잠시 후 다시 시도해주세요.”`

```java
// Resilience4j를 사용한 서킷 브레이커 + Fallback 예시
@Service
public class ExternalApiService {

    @CircuitBreaker(name = "externalApi", fallbackMethod = "fallbackCall")
    public String callExternalApi() {
        // ... 외부 서비스 호출 로직 (RestTemplate, Feign Client 등) ...
    }

    // Fallback 메소드: 원본 메소드와 시그니처가 유사해야 함
    public String fallbackCall(Throwable t) {
        log.warn("외부 서비스 장애. Fallback 실행: {}", t.getMessage());
        return "현재 서비스 점검 중입니다. 잠시 후 이용해주세요.";
    }
}
```

## 실무에서는?

실무에서는 서킷 브레이커 패턴을 많이 사용합니다.

서킷 브레이커 패턴은 특히 MSA 환경의 실무에서 선택이 아닌 필수로 간주되는 핵심 패턴입니다.

과거에는 Netfix의 Hystrix가 표준처럼 쓰였지만, 현재는 지원이 중단되어 Resilience4j가 Spring Boot 생태계의 사실상 표준으로 사용되고 있습니다.

### 실무에서 서킷 브레이커가 필수인 이유

MSA 환경에서는 하나의 요청을 처리하기 위해 내부적으로 수많은 서비스가 동기식으로 통신합니다.

서킷 브레이커가 없다면, 이 중 가장 중요하지 않은 서비스의 장애가 전체 시스템을 마비시키는 연쇄 장애로 이어집니다.

- 장애 시나리오 (서킷 브레이커 없음)
  1. ‘추천 상품’ 서비스가 DB문제로 응답이 30초씩 걸리기 시작합니다.
  2. ‘상품 주문’ 서비스는 ‘추천 상품’ 서비스를 동기 호출하며 30초가 스레드가 대기합니다.
  3. 주문 요청이 초당 10개만 들어와도, 30초 뒤에는 300개의 스레드가 모두 대기 상태에 빠집니다.
  4. 톰캣(WAS) 스레드 풀이 고갈되어, ‘상품 주문’서비스는 ‘추천 상품’과 관계없는 ‘결제’나 ‘주문 내역 조회’ 같은 핵심 기능 조차 수행하지 못하고 함께 다운합니다.

서킷 브레이커는 이 연쇄를 끊어내는 역할을 합니다.

### 적용

Resilience4j 라이브러리를 사용하여 이 패턴을 간단하게 적용합니다.

application.yml에 전역 설정

```yaml
resilience4j:
  circuitbreaker:
    configs:
      # 'default' 설정: 모든 서킷 브레이커에 기본으로 적용될 규칙
      default:
        # 1. 언제 서킷을 OPEN 할 것인가? (실패 임계값)
        failureRateThreshold: 50 # (실패율) 최근 100번의 호출 중 50% (50번) 실패하면 서킷 OPEN
        slidingWindowType: COUNT_BASED # (기준) 최근 100번의 '호출 수' 기준
        slidingWindowSize: 100 # (기준 값) 최근 100번의 호출
        minimumNumberOfCalls: 10 # 최소 10번은 호출해보고 통계를 계산 (10번 미만일땐 OPEN 안함)

        # 2. OPEN 되었을 때 얼마나 지속할 것인가?
        waitDurationInOpenState: 10000 # (10초) OPEN 상태를 10초간 유지 (장애난 서비스가 회복할 시간)

        # 3. HALF-OPEN 상태에서 어떻게 테스트할 것인가?
        permittedNumberOfCallsInHalfOpenState: 5 # 10초 뒤, 테스트 요청 5번만 허용
        # (5번이 모두 성공하면 -> CLOSED / 1번이라도 실패하면 -> 다시 OPEN)

    instances:
      # 'payment'라는 이름의 서킷 브레이커는 'default' 설정을 사용
      paymentService:
        baseConfig: default

      # 'recommend' 서킷 브레이커는 기본 설정 대신 'slow' 설정을 사용 (커스텀 가능)
      recommendService:
        failureRateThreshold: 70
```

@CricuitBreaker 어노테이션 적용

```java
// 상품 서비스 (OrderService)
@Service
public class OrderService {

    private final PaymentClient paymentClient; // Feign Client 또는 RestTemplate
    private final RecommendClient recommendClient;

    public OrderService(PaymentClient paymentClient, RecommendClient recommendClient) {
        this.paymentClient = paymentClient;
        this.recommendClient = recommendClient;
    }

    public OrderResponse placeOrder(OrderRequest request) {
        // ... (1) 주문 로직 ...

        // (2) 결제 서비스 호출: "paymentService"라는 이름의 서킷 브레이커가 감싼다.
        @CircuitBreaker(name = "paymentService", fallbackMethod = "fallbackForPayment")
        String paymentResult = paymentClient.pay(request.getAmount());

        // (3) 추천 서비스 호출: "recommendService"라는 이름의 서킷 브레이커가 감싼다.
        @CircuitBreaker(name = "recommendService", fallbackMethod = "fallbackForRecommend")
        List<Product> recommendations = recommendClient.getRecommendations(request.getUserId());

        // ... (4) 주문 완료 및 응답 반환 ...
        return new OrderResponse(paymentResult, recommendations);
    }

    // [중요] 결제 서비스 장애 시 실행될 '폴백 메소드'
    private String fallbackForPayment(Throwable t) {
        log.warn("결제 서비스 장애 발생. Fallback 실행: {}", t.getMessage());
        // 결제 실패 시 주문은 무조건 실패해야 함
        throw new OrderFailedException("결제 서비스가 응답하지 않습니다.");
    }

    // [중요] 추천 서비스 장애 시 실행될 '폴백 메소드'
    private List<Product> fallbackForRecommend(Throwable t) {
        log.warn("추천 서비스 장애 발생. Fallback 실행: {}", t.getMessage());
        // 추천 서비스는 '부가 기능'이므로, 실패해도 주문은 성공해야 함
        // 빈 리스트(기본값)를 반환하여 주문을 계속 진행
        return Collections.emptyList();
    }
}
```

### 폴백의 비즈니스적 분리

위 코드의 fallbackForPayment와 fallbackForRecommend가 실무의 핵심입니다. 서킷이 터졌을 때 “그래서 대신 뭘 할 건데?”를 정의해야 합니다.

- 핵심 기능 (결제): paymentService가 터지면, 폴백 메소드는 주문을 실패시킵니다. 핵심 기능이 실패하면 비즈니스는 중단되어야 합니다.
- 부가 기능 (추천): recommendService가 터지면, 폴백 메소드는 빈 리스트(기본값)를 반환합니다. 부가 기능이 실패해도 핵심 비즈니스(주문)는 계속되어야 합니다.

이처럼 서킷 브레이커를 통해 장애를 겪리하고, 폴백을 통해 비즈니스 영향도를 분리하여 시스템의 안정성을 확보합니다.
