---
title: 자바 클래스 정보
description: 자바에서 클래스 정보는 어떻게 알아낼 수 있나요?
date: 2026-02-19
tags: []
---

자바에서는 리플렉션 API를 사용하여 실행 중에 클래스의 이름, 필드, 메소드, 생성자 등의 정보를 알아낼 수 있습니다.

리플렉션은 구체적인 클래스 타입을 알지 못해도, 그 클래스의 메소드나 변수 등에 접근할 수 있게 해주는 강력한 자바의 기능입니다. 스프링 프레임워크나 JUnit 같은 라이브러리들이 내부적으로 이 기술을 적극 활용합니다.

클래스 정보를 알아내는 단계는 크게 1. Class 객체 획득, 2. 정보 추출, 3. 조작으로 나뉩니다.

## 1. Class 객체 획득하기

리플렉션을 시작하려면 먼저 해당 클래스의 메타데이터를 담고 있는 Class 객체를 얻어야 합니다.

1. 클래스 타입으로 직접 획득 (.class)
   - 컴파일 타임에 클래스를 알고 있을 때 사용합니다.

   ```java
   Class<?> clazz = String.class;
   ```

2. 객체(인스턴스)로부터 획득 (.getClass())
   - 이미 생성된 객체가 있을 때 사용합니다.

   ```java
   String str = "Hello";
   Class<?> clazz = str.getClass();
   ```

3. 클래스 이름(문자열)으로 획득 (Class.forName())
   - 런타임에 동적으로 클래스를 로딩할 때 사용합니다.

   ```java
   Class<?> clazz = Class.forName("java.lang.String");
   ```

## 2. 정보 추출 및 활용 예제

Class 객체를 얻었다면, 다음과 같은 메소드들을 통해 내부 정보를 샅샅이 뒤질 수 있습니다.

- getMethods() / getDeclaredMethods(): 메소드 목록
- getFields() / getDeclaredFields(): 필드(변수) 목록
- getConstructors(): 생성자 목록
- getInterfaces(): 구현한 인터페이스 목록

```java
import java.lang.reflect.Field;
import java.lang.reflect.Method;

public class ReflectionTest {
    public static void main(String[] args) throws Exception {
        // 1. Class 객체 획득
        Class<?> clazz = Class.forName("java.util.ArrayList");

        System.out.println("--- 클래스 이름 ---");
        System.out.println(clazz.getName());

        System.out.println("\n--- 메서드 목록 (일부) ---");
        Method[] methods = clazz.getDeclaredMethods();
        for (Method method : methods) {
            System.out.println(method.getName());
        }

        System.out.println("\n--- 필드 목록 ---");
        Field[] fields = clazz.getDeclaredFields();
        for (Field field : fields) {
            // private 필드도 접근 가능하게 설정 (보안 위배 주의)
            field.setAccessible(true);
            System.out.println(field.getName() + " (" + field.getType().getSimpleName() + ")");
        }
    }
}
```

## 3. 단점

리플렉션은 마법 같은 기능이지만, 남용하면 안됩니다.

1. 성능 저하
   - 컴파일 타임에 최적화된 코드가 아니라, 런타임에 동적으로 해석하므로 일반적인 메소드 호출보다 훨
     씬 느립니다.
2. 컴파일 타임 타입 체크 불가
   - 없는 메소드를 호출하려 하거나 오타가 있ㄷ어도, 컴파일러가 잡아내지 못하고 실행 시에 RunTimeException이 발생합니다.
3. 내부 노출 (캡슐화 파괴)
   - setAccessible(true)를 사용하면 private 메소드나 필드에도 강제로 접근할 수 있습니다. 이는 객체 지향의 정보 은닉 원칙을 위배하므로 테스트 목적 외에는 신중해야 합니다.

## 정리

- 리플렉션: 런타임에 클래스 정보를 분석하고 조작하는 기술
- 핵심: Class.forName(”이름”) 등으로 Class 객체를 얻은 뒤, getMethods(), getFields() 등을 호출하여 정보를 빼냅니다.
- 용도: IDE의 자동완성 기능, 스프링 프레임워크의 의존성 주입(DI), JSON 파서 등에서 주로 사용됩니다.
