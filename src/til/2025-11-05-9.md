---
title: 트랜잭션 격리수준
description: 트랜잭션 격리수준은 무엇인가요?
date: 2025-11-05
tags: [데이터베이스, 트랜잭션, 격리수준]
---

# 트랜잭션 격리 수준이란?

트랜잭션 격리 수준이란, 여러 트랜잭션이 동시에 실행될 때 특정 트랜잭션이 다른 트랜잭션의 변경 내용을 얼마나 볼 수 있도록 허용할 것인지를 결정하는 기준입니다.

이는 데이터베이스의 ACID 속성 중 Isolation(고립성)을 구체화하는 개념입니다.

고립성을 완벽하게 보장하려면(즉, 모든 트랜잭션이 순차적으로 실행되는 것처럼 동작하게 하려면) 시스템의 동시성(Concurrency)이 크게 저하됩니다.

반대로 동시성을 높이면(여러 트랜잭션을 동시에 실행하면) 데이터의 일관성이 깨질 수 있는 문제가 발생합니다.

트랜잭션 격리 수준은 이러한 ‘데이터 일관성’과 ‘동시성’ 사이의 트레이드 오프를 조절하기 위한 표준화된 설정값입니다.

# 격리 수준이 필요한 이유 - 동시성 문제

격리 수준을 낮게 설정할 경우(동시성을 높일 경우), 다음과 같은 주요 부정합 문제들이 발생할 수 있습니다.

1. Dirty Read (더티 리드)
   - 아직 커밋되지 않은, 다른 트랜잭션의 수정 중인 데이터를 읽는 것을 의미합니다.
   - 데이터를 읽었으나 해당 트랜잭션이 롤백 된다면, 읽어들인 데이터는 존재하지 않는 더러운 데이터가 되어 일관성이 깨집니다.
2. Non-Repeatable Read (반복 불가능한 읽기)
   - 한 트랜잭션 내에서 동일한 쿼리를 두 번 실행했을 때, 그 사이에 다른 트랜잭션이 값을 수정(UPDATE)하고 커밋하여 두 쿼리의 결과가 다르게 나타나는 현상입니다.
   - 트랜잭션이 진행되는 동안 자신이 읽은 데이터의 일관성을 신뢰할 수 없게 됩니다.
3. Phantom Read (유령 읽기)
   - 한 트랜잭션 내에서 동일한 범위 쿼리(예: WHERE age > 20)를 두 번 실행했을 때, 그 사이에 다른 트랜잭션이 새로운 레코드를 삽입(INSERT) 또는 삭제(DELETE)하고 커밋하여 첫 번째 쿼리에서는 보이지 않던 유령 레코드가 나타나거나 사라지는 현상입니다.
   - Non-Repeatable Read가 특정 행(Row)의 변경에 관한 것이라면, Phantom Read는 특정 범위의 변경에 관한 문제입니다.

# 표준 4가지 격리 수준

SQL 표준은 이러한 문제들을 제어하기 위해 4가지 격리 수준을 정의합니다. 수준이 높아질수록 일관성은 높아지지만 동시성은 낮아집니다.

## Level 0: Read Uncommitted (커밋되지 않은 읽기)

- 동작: 다른 트랜잭션이 커밋하지 않은 데이터(Dirty Data)를 읽는 것을 허용합니다.
- 허용되는 문제: Dirty Read, Non-Repeatable Read, Phantom Read (모든 문제 발생)
- 특징: 동시성은 가장 높지만, 데이터 일관성은 보장되지 않습니다. 거의 사용되지 않습니다.

## Level 1: Read Committed (커밋된 읽기)

- 동작: 트랜잭션이 커밋된 데이터만 읽도록 허용합니다.
- 방지되는 문제: Dirty Read
- 허용되는 문제: Non-Repeatable Read, Phantom Read
- 특징: 대부분의 상용 RDBMS의 기본 격리 수준입니다. 트랜잭션이 실행되는 동안 읽는 데이터에 대해 공유 락을 걸지만, 쿼리가 끝나는 즉시 락을 해제하므로 다른 트랜잭션이 값을 수정할 수 있습니다.

## Level 2: Repeatable Read (반복 가능한 읽기)

- 동작: 트랜잭션이 시작된 시점의 데이터를 일관되게 읽도록 보장합니다. 즉, 트랜잭션 내에서 동일한 쿼리는 항상 동일한 결과를 반환합니다.
- 방지되는 문제: Dirty Read, Non-Repeatable Read
- 허용되는 문제: Phantom Read
- 특징: MySQL(InnoDB 스토리지 엔진)의 기본 격리 수준입니다. 이는 MVCC(다중 버전 동시성 제어)를 통해 구현되며, 트랜잭션이 시작될 때 ‘스냅샷’을 생성하여 해당 트랜잭션 동안은 그 스냅샷만 참조하게 합니다.

## Level 3: Serializable (직렬화 가능)

- 동작: 트랜잭션을 마치 순차적으로(직렬로) 하나씩 실행하는 것과 동일한 결과를 보장합니다.
- 방지되는 문제: Dirty Read, Non-Repeatable Read, Phantom Read
- 특징: 가장 엄격한 격리 수준으로 완벽한 데이터 일관성을 제공합니다.
- 구현: 일반적으로 읽기 작업에도 공유 락을 걸고 트랜잭션이 끝날 때까지 유지하며, 범위 쿼리시에는 갭 락 등을 사용하여 새로운 데이터 삽입을 막습니다. 이로 인해 동시성이 심각하게 저하될 수 있어 성능이 매우 중요한 시스템에서는 사용을 기피합니다.

# 구현 방식

격리 수준을 구현하는 방식은 크게 두 가지입니다.

## 1. Pessimistic Locking (비관적 잠금)

- 충돌은 어차피 일어날 것이라고 가정하고, 데이터에 접근할 때부터 락을 거는 방식입니다.
- SELECT … FOR UPDATE (베타적 락) 또는 SELECT … IN SHARE MODE (공유 락) 등이 여기에 해당합니다.
- Serializable 수준은 이 락을 매우 광범위하게 사용합니다.

## 2. MVCC (Multi-Version Concurrency Control, 다중 버전 동시성 제어)

- 충돌은 자주 일어나지 않을 것이라고 가정하고, 락을 거는 대신 데이터의 여러 버전을 관리하는 방식입니다.
- 데이터를 수정할 때마다 원본을 덮어쓰지 않고, 새로운 버전(스냅샷)을 생성하고 트랜잭션 ID를 부여합니다.
- 각 트랜잭션은 자신이 시작된 시점을 기준으로 볼 수 있는 데이터의 버전(스냅샷)을 읽습니다.
- Read Committed와 Repeatable Read 수준은 대부분 MVCC를 통해 구현됩니다. (Oracle, PostreSQL, MySQL InnoDB)
- MVCC 덕분에 읽기 작업(SELECT)이 쓰기 작업(UPDATE)을 차단(Blocking)하지 않고, 쓰기 작업 또한 읽기 작업을 차단하지 않아 동시성이 획기적으로 향상됩니다.
