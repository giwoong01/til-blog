---
title: SOLID 원칙
description:
date: 2025-12-15
tags: [SOLID]
---

SOLID 원칙은 객체 지향 설계 5대 원칙을 일컫는 약자로, 소프트웨어 아키텍처와 디자인 패턴의 기본입니다. 이 원천들은 로버트 C. 마틴이 제시했으며, 시스템을 유연하고, 유지보수하기 쉬우며, 확장하기 용이하게 만드는 것을 목표로 합니다.

각 알파벳이 의미하는 5가지 원칙은 다음과 같습니다.

## 1. S: 단일 책임 원칙 (SRP, Single Responsibility Principle)

“하나의 클래스는 하나의, 오직 하나의 변경 이유만을 가져야 한다.”

- 정의: 클래스가 수행하는 역할은 오직 하나여야 함을 의미합니다. 만약 클래스에 두 가지 이상의 역할이 부여된다면, 그 두 가지 역할을 수정해야 할 이유가 각각 생길 때마다 해당 클래스가 변경되어야 합니다.
- 실무적 정용: 클래스가 데이터 저장(Entity), 비즈니스 로직(Service), 화면 출력(Controller/View) 등 두 가지 이상의 책임을 가지지 않도록 분리합니다.
- 예시: User 클래스에 사용자 데이터 저장 역할과 이메일 전송 역할을 모두 넣는 대신, User 클래스는 데이터만 가지고, EmailSender 클래스를 따로 만들어 이메일 전송 책임을 위임해야 합니다.

## 2. O: 개방-폐쇄 원칙 (OCP, Open-Closed Principle)

“소프트웨어 개체(클래스, 모듈, 함수 등)는 확장에 대해서는 개방적이어야 하고, 수정에 대해서는 폐쇄적이어야 한다.”

- 정의: 기존 코드를 수정하지 않고도 시스템의 기능을 확장할 수 있어야 함을 의미합니다. 이는 변하지 않는 부분(추상화)과 변하는 부분(구현)을 명확히 분리하여 달성합니다.
- 실무적 적용: 다형성을 활용합니다. 기능 변경이 필요할 때 기존 클래스를 직접 수정하는 대신, 인터페이스나 추상 클래스를 상속받아 새로운 클래스만 추가합니다.
- 예시: Payment 처리 시, 새로운 결제 수단(KakaoPay, NaverPay)이 추가되더라도 기존의 PaymentService 코드를 수정하지 않고, PaymentGateway 인터페이스를 구현하는 새로운 클래스만 추가하여 확장합니다.

## 3. L: 리스코프 치환 원칙 (LSP, Liskov Substitution Principle)

“자식 타입은 언제나 부모 타입으로 대체될 수 있어야 한다.”

- 정의: 상속받은 하위 클래스는 상위 클래스의 행위와 규악을 위반해서는 안됩니다. 즉, 클라이언트 코드는 부모 객체를 사용하든 자식 객체를 사용하든 동일하게 예상된 동작을 해야 합니다.
- 실무적 적용: 단순히 메소드의 시그니처만 일치시키는 것이 아니라, 행위의 일관성을 유지해야 합니다. 자식 클래스에서 부모 클래스의 메소드를 오버라이딩할 때, 예상치 못한 예외를 던지거나 기능의 의미를 완전히 바꾸면 LSP를 위반합니다.
- 예시: Square 클래스가 Rectangle 클래스를 상속받을 때, Square에서 setWidth(x)를 호출하면 높이까지 x로 바뀌는 경우, 부모인 Rectangle의 행위를 위반하므로 LSP를 위반합니다.

## 4. I: 인터페이스 분리 원칙 (ISP, Interface Segregation Principle)

“클라이언트는 자신이 사용하지 않는 메소드에 의존해서는 안 된다.”

- 정의: 하나의 거대하고 포괄적인 인터페이스를 만드는 대신, 클라이언트의 사용 목적에 맞게 작고 구체적인 여러 개의 인터페이스로 분리해야 함을 의미합니다.
- 실무적 적용: 클라이언트는 자신이 필요한 기능만 정의된 인터페이스를 주입받아 사용해야 합니다.
- 예시: Giantworker라는 인터페이스에 walk(), eat(), fly(), sing() 같은 수십 개의 메소드가 있을 때, Robot 클래스가 fly()나 sing()이 필요 없더라도 이 인터페이스를 구현해야 하는 문제를 피해야 합니다. 대신, Movable, Eatable, singable 등으로 분리하고 Robot은 필요한 Movable만 구현해야 합니다.

## 5. D: 의존성 역전 원칙 (DIP, Dependency Inversion Principle)

“추상화에 의존하라. 구체화에 의존하면 안 된다.” “고수준 모듈은 저수준 모듈에 의존해서는 안 된다. 두 모듈 모두 추상화에 의존해야 한다.”

- 정의: 핵심 로직(고수준 모듈)은 구체적인 기술(저수준 모듈)에 직접 의존하지 않고, 추상화된 인터페이스에 의존해야 합니다.
- 실무적 적용: 이 원칙은 제어의 역전(IoC)과 의존성 주입(DI)을 통해 달성됩니다. Spring 프레임워크에서 DI를 사용하는 이유가 바로 이 DIP를 지키기 위함입니다.
- 예시: OrderService (고수준 모듈)는 구체적인 MySQLRepository (저수준 모듈)를 직접 생성하거나 의존하지 않고, OrderRepository 인터페이스(추상화)에 의존해야 합니다. 구체적인 구현체는 외부에서 주입받습니다.
