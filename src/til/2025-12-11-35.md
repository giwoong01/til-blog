---
title: Record를 DTO로 사용하는 이유는?
description:
date: 2025-12-11
tags: [Java, Record, DTO]
---

Java 14에서 도입(Java 16에서 정식 스펙)된 Record는 “불변 데이터를 운반하는 투명한 홀더”라는 명확한 목적을 가지고 탄생했습니다.

DTO의 정의가 “계층 간 데이터 교환을 위해 사용하는, 로직을 갖지 않는 순수한 데이터 객체”임을 생각할 때, Record는 DTO를 위해 태어난 기능이라고 해도 과언이 아닙니다.

Record를 DTO로 사용하는 핵심적인 이유 4가지입니다.

## 1. 불변성 보장

DTO는 데이터를 A계층에서 B계층으로 배달하는 택배 상자와 같습니다. 배달 도중에 상자 안의 내용물이 바뀌면 안됩니다.

- 기존 Class: 불변으로 만드려면 모든 필드에 final을 붙이고, Setter를 만들지 않아야 하는 등 개발자가 신경 써야 할 규칙이 많습니다. 실수로 Setter를 열어두면 데이터 오염의 위험이 생깁니다.
- Record: 태생적으로 불변입니다.
  - 모든 필드는 자동으로 private final입니다.
  - Setter가 아예 생성되지 않습니다.
  - 한번 생성된 DTO는 데이터가 변하지 않음을 언어 차원에서 보장하므로, 멀티 스레드 환경에서도 안전하고 데이터의 흐름을 추적하기 쉽습니다.

## 2. 보일러플레이트 코드 제거

DTO를 만들 때마다 반복적으로 작성해야 했던 지루한 코드들이 사라집니다.

- 기존 Class: 필드 선언, Getter, equals(), hashCode(), toString()을 모두 작성하거나, Lombok에 의존해야 했습니다.
- Record: 컴파일러가 위 모든 메소드를 자동으로 생성해 줍니다. 이는 코드의 가독성을 극대화합니다.

기존 Class 방식

```java
public class UserDto {
    private final String name;
    private final int age;

    public UserDto(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() { return name; }
    public int getAge() { return age; }

    // + equals(), hashCode(), toString() ... (수십 줄)
}
```

Record 방식

```java
public record UserDto(String name, int age) { }
```

## 3. 데이터 운반이라는 의미의 명확성

코드는 작성하는 것만큼 읽는 것도 중요합니다.

- Class: `public class UserDto`라고 써있으면, 코드를 열어보기 전까지는 이것이 단순 데이터 덩어리인지, 복잡한 기능을 가진 객체인지, 상속을 받는지 알기 어렵습니다.
- Record: `public record UserDto`라고 써있는 순간, 읽는 사람은 “아, 이건 데이터를 담고 있는 불변 객체구나. 다른 로직은 없겠구나.”라고 즉시 파악할 수 있습니다.

## 4. equals()와 hashCode()의 완벽한 구현

DTO는 값 그 자체가 중요한 객체이므로, 인스턴스 주소가 달라도 내부 값이 같으면 같은 객체로 취급되어야 합니다.(동등성)

- Map의 Key로 사용: HashMap이나 HashSet 등에 DTO를 저장할 때 equals와 hashCode가 제대로 구현되지 않으면 심각한 버그가 발생합니다. (데이터 유실 등)
- Record의 장점: Record는 모든 필드 값을 기반으로 완벽한 equals와 hashCode를 자동으로 생성해줍니다. 따라서 컬렉션 프레임워크에서 사용하거나 테스트 코드에서 객체를 비교할 때 매우 안전하고 편리합니다.

## 주의사항: 언제 사용하면 안 되는가?

Record가 DTO로는 완벽하지만, JPA 엔티티로 사용하는 것은 권장하지 않습니다.

1. JPA의 프록시 매커니즘: JPA는 지연 로딩 등을 위해 엔티티의 프록시 객체를 생성해야 하는데, Record는 final 클래스라 상속이 불가능하여 프록시를 만들 수 없습니다.
2. 불변성: 엔티티는 비즈니스 로직에 의해 상태가 변경되어야 하는데, Record는 수정이 불가능합니다.
3. Setter 부재: 데이터베이스 매핑 과정에서 유연성이 떨어집니다.

## 정리

- DTO (데이터 전달): Record 사용
- Entity (데이터베이스 매핑): Class 사용
