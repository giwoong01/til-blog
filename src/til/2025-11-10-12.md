---
title: JPA ID 생성 전략
description: JPA에서 ID 생성 전략은 무엇이 있을까요?
date: 2025-11-10
tags: [Spring Boot, Java, JPA]
---

# JPA란?

먼저 JPA란 무엇인지부터 살펴보겠습니다.

JPA는 자바 애플리케이션에서 관계형 데이터베이스를 사용하는 방식을 표준화한 자바의 기술 명세입니다.

JPA는 그 자체가 특정 기능을 수행하는 라이브러리가 아니라, “데이터베이스와 이렇게 상호작용해야 한다”라고 정의한 인터페이스 규약입니다. 개발자는 이 규약을 따르는 실체 구현체를 사용하게 되며, 가장 대표적인 구현체가 바로 하이버네이트입니다.

(Spring Boot는 기본적으로 Hibernate를 JPA 구현체로 사용합니다.)

## JPA의 목적: 패러다임의 불일치 해결

JPA가 등장한 이유는 자바의 객체지향 프로그래밍(OOP)과 관계형 데이터베이스 간의 근본적인 ‘패러다임 불일치’ 문제를 해결하기 위해서입니다.

- 객체 지향(Java): 상속, 다형성, 참조 등을 통해 데이터를 객체 그래프로 다룹니다. (예: User 객체가 Team 객체를 참조)
- 관계형 DB(SQL): 데이터를 2차원의 테이블에 정규화합니다. (예: USER 테이블의 team_id 외래 키로 TEAM 테이블 참조)

개발자가 Java 코드에서 SQL 쿼리를 직접 작성(JDBC)하면, 이 두 패러다임의 불일치로 인해 반복적이고 지루한 변환 작업을 수행해야 합니다. (SQL 결과를 Java 객체로 변환, 객체 변경을 UPDATE SQL로 변환 등)

## ORM (Object-Relational Mapping)

JPA는 ORM(객체 관계 매핑) 기술을 표준화한 것입니다.

ORM은 이름 그대로 자바 객체와 DB 테이블을 자동으로 매핑해줍니다.

- 개발자는 @Entity, @Table, @Column 같은 어노테이션을 사용하여 자바 클래스가 DB의 어떤 테이블과 매핑되는지 선언합니다.
- 개발자는 userRepository.save(user)처럼 자바 객체를 조작하는 코드만 작성합니다.
- JPA(Hibernate)가 이 객체 조작을 분석하여, 해당 DB에 맞는 적절한 SQL을 자동으로 생성하고 실행해 줍니다.

이를 통해 개발자는 SQL 중심이 아닌 객체 중심의 비즈니스 로직 개발에만 집중할 수 있게 됩니다.

# JPA의 ID 생성 전략

모든 JPA 엔티티(@Entity)는 테이블의 기본 키에 매핑되는 @Id 필드를 반드시 가져야 합니다.

@GeneratedValue 어노테이션은 이 @Id 값을 데이터베이스가 자동으로 생성하도록 위임할 때 사용하는 전략을 정의합니다.

@GeneratedValue(strategy = …)에 설정하는 GenerationType에는 4가지 전략이 있습니다.

## 1. GenerationType.AUTO (Default)

특정 전략을 명시하지 않고, JPA 구현체가 연결된 데이터베이스의 방언을 분석하여 4가지 전략 중 가장 적절한 것을 자동으로 선택합니다.

- MySQL, MariaDB : GenerationType.IDENTITY를 선택합니다.
- Oracle, PostgreSQL, H2 : GenerationType.SEQUENCE를 선택합니다.
- 과거 버전의 Hibernate는 DB 종류와 상관없이 TABLE 전략을 선택했습니다.

AUTO는 편리하지만, DB를 변결할 때 ID 생성 전략이 의도치 않게 바뀔 수 있어 명확성이 떨어집니다. 따라서 DB에 맞는 IDENTITY 또는 SEQUENCE를 명시적으로 지정하는 것이 권장됩니다.

## 2. GenerationType.IDENTITY

ID 생성을 데이터베이스에 완전히 위임합니다.

- MySQL의 AUTO_INCREMENT, PostgreSQL의 SERIAL, SQL Server의 IDENTITY 컬럼 등, DB가 INSERT 시점에 ID를 자동으로 증가시키는 기능을 사용할 때 선택합니다.

### 동작 방식

1. 개발자가 userRepository.save(user)를 호출합니다.
2. JPA는 이 엔티티를 영속성 컨텍스트에 저장합니다.
3. 하지만 IDENTITY 전략에서는 DB에 INSERT 쿼리가 실제로 실행되어야만 DB가 생성한 ID 값을 알 수 있습니다.
4. 따라서 JPA는 persist()호출 즉시 INSERT SQL을 데이터베이스로 전송(flush)합니다.

### 특징 (성능상 단점)

이 전략은 트랜잭션 커밋 시점까지 SQL을 모아서 한 번에 전송하는 JPA의 쓰기 지연 최적화 기능을 사용할 수 없습니다.

persist() 호출마다 즉시 DB와 통신해야 합니다.

```java
@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    // ...
}
```

## 3. GenerationType.SEQUENCE

데이터베이스의 시퀀스 오브젝트를 통해 유일한 ID 값을 미리 할당받아 사용하는 전략입니다.

- Oracle, PostgreSQL, H2 등 시퀀스를 지원하는 대부분의 RDBMS

### 동작 방식

1. persist(user)가 호출되면, JPA는 먼저 DB의 시퀀스 조회하여 ID 값을 미리 가져옵니다.
2. 가져온 ID를 엔티티 객체의 @Id 필드에 할당합니다.
3. ID가 할당된 엔티티를 영속성 컨텍스트에 저장합니다.
4. 실제 INSERT SQL은 쓰기 지연에 따라 트랜잭션이 커밋되는 시점에 DB로 전송됩니다.

### 특징 (성능상 장점)

- IDENTITY와 달리 쓰기 지연이 가능하여 JDBC 배치 작업 등 성능 최적화가 가능합니다.
- allocationSize 최적화: @SequenceGenerator를 통해 allocationSize를 설정할 수 있습니다.
  - JPA는 시퀀스를 1번 호출할 때마다 50개의 ID를 미리 가져와 애플리케이션 메모리에 캐싱합니다.
  - 이후 50번의 persist()는 DB 통신 없이 메모리의 ID를 순차적으로 사용하므로 성능이 비약적으로 향상됩니다. (Spring Boot의 SEQUENCE 기본 allocationSize는 50입니다.)

```java
@Entity
@SequenceGenerator(
    name = "USER_SEQ_GENERATOR",
    sequenceName = "USER_SEQ", // DB에 생성된 시퀀스 이름
    initialValue = 1, allocationSize = 50)
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE,
                    generator = "USER_SEQ_GENERATOR")
    private Long id;
    // ...
}
```

## 4. GenerationType.TABLE

ID 생성 전용 키 관리 테이블을 별도로 만들어두고, 이 테이블의 특정 행을 조회하고 수정하면서 ID를 생성하는 방식입니다.

### 동작 방식

시퀀스 오브젝트를 흉내 내는 방식입니다. ID가 필요할 때마다 해당 테이블의 특정 행에 락을 걸고 값을 +1 하여 사용합니다.

### 특징

- 모든 DB에서 사용 가능하므로 호환성은 좋으나, ID를 얻기 위해 테이블에 SELECT와 UPDATE를 실행해야 하므로 4가지 전략 중 성능이 가장 나쁩니다.
- 특별한 이유가 없다면 사용하지 않는 것이 좋습니다.

# 쓰기 지연이란?

위에서 쓰기 지연이라는 말이 몇 번 나왔습니다.

쓰기 지연은 JPA가 성능을 최적화하기 위해 사용되는 매우 중요한 내부 동작 방식입니다.

간단히 말해, INSERT, UPDATE, DELETE같은 SQL 쿼리들을 당장 실행하지 않고, SQL 쓰기 지연 저장소라는 내부 큐(Queue)에 차곡차곡 모아두었다가, 트랜잭션이 커밋되는 시점에 한꺼번에 데이터베이스로 전송(Flush)하는 기술입니다.

## 비유: 장바구니 결제

가장 쉽게 설명하는 비유가 온라인 쇼핑몰 장바구니 입니다.

- 쓰기 지연이 없는 경우 (IDENTITY 전략)
  - 물건 1(객체)을 save()합니다. → 즉시 DB로 INSERT (1번 결제)
  - 물건 2(객체)을 save()합니다. → 즉시 DB로 INSERT (2번 결제)
  - 물건 3(객체)을 save()합니다. → 즉시 DB로 INSERT (3번 결제)
  - 결과: 3개의 객체를 저장하기 위해 DB와 3번의 통신을 합니다. 매우 비효율적입니다.
- 쓰기 지연이 있는 경우 (SEQUENCE 전략)
  - 물건 1(객체)을 save()합니다. → SQL 큐(장바구니)에 담습니다. (DB 통신 X)
  - 물건 2(객체)을 save()합니다. → SQL 큐(장바구니)에 담습니다. (DB 통신 X)
  - 물건 2(객체)을 save()합니다. → SQL 큐(장바구니)에 담습니다. (DB 통신 X)
  - 트랜잭션이 COMMIT 됩니다. (결제 버튼 클릭)
  - JPA가 장바구니에 모인 3개의 INSERT SQL을 단 하나의 배치 작업으로 묶어 DB에 한 번만 전송합니다.
  - 결과: 3개의 객체를 저장하기 위해 DB와 1번 통신합니다. 매우 효율적입니다.

## JPA에서의 실제 동작 (영속성 컨텍스트)

이 장바구니 역할을 하는 것이 바로 JPA의 영속성 컨텍스트입니다.

1. entityManager.persist(user) 호출
   - JPA는 INSERT SQL을 생성해서 SQL 쓰기 지연 저장소에 등록합니다.
   - user 객체는 영속성 컨텍스트의 1차 캐시에 저장되어 관리됩니다.
   - 이 시점에는 DB에 어떤 쿼리도 전송되지 않습니다.
2. transaction.commit() 호출
   - 트랜잭션 커밋이 요청되면, JPA는 영속성 컨텍스트를 플러스(Flush)합니다.
   - 플러시가 발생하는 순간, SQL 쓰기 지연 저장소에 쌓여있던 모든 SQL(INSERT, UPDATE)들이 DB로 전송됩니다.
   - 이때 JPA는 JDBC 배치 기능을 사용하여 SQL을 최적화해서 보냅니다.
   - DB가 모든 쿼리를 성공적으로 처리하면, 실제 DB 트랜잭션이 커밋됩니다.

## 장점: 배치 처리

쓰기 지연의 가장 큰 목적은 JDBC 배치 처리를 가능하게 하여 네트워크 비용을 최소화하는 것입니다.

애플리케이션에서 가장 비싼 작업 중 하나는 SQL 쿼리를 실행하기 위해 DB와 네트워크 통신을 주고받는 것입니다.

- 쿼리 100개 \* 1ms 실행 = 100ms (실제 DB 작업 시간)
- 네트워크 통신 100번 \* 10ms = 1000ms (네트워크 지연 시간)

쓰기 지연과 배치 처리를 사용하면, 이 네트워크 통신 100번을 1번으로 줄여주기 때문에 애플리케이션의 전체적인 처리량이 극적으로 향상됩니다.

## GenerationType.IDENTITY가 쓰기 지연을 못 쓰는 이유

- persist(user)를 호출했을 때, SEQUENCE 전략은 DB 시퀀스에서 ID를 미리 받아와 user 객체에 채워 넣고 영속성 컨텍스트에서 관리할 수 있었습니다.
- 하지만 IDENTITY 전략은 INSERT SQL이 DB에서 실제로 실행되어야만 AUTO_INCREMENT로 생성된 ID 값을 알 수 있습니다.
- JPA는 영속성 컨텍스트에서 객체를 관리(캐싱)하기 위해 ID 값이 반드시 필요합니다.
- 따라서 JPA는 persist(user)가 호출되는 즉시 INSERT 쿼리를 DB로 전송(Flush)하여 ID 값을 받아와야만 합니다. 이 때문에 ‘SQL을 모았다가 한 번에 보내는’ 쓰기 지연 최적화가 불가능해집니다.
