---
title: private 메서드에 @Transactional 선언하면 트랜잭션이 동작하는가
description:
date: 2025-12-03
tags: [private, 트랜잭션]
---

Spring의 기본 설정(프록시 모드)에서는 private 메소드에 `@Transactional`을 붙여도 트랜잭션이 적용되지 않으며, 심지어 에러가 발생하지도 않고 그냥 무시됩니다.

그 이유는 Spring AOP의 동작 원리(프록시 패턴) 때문입니다.

## Spring AOP(관점 지향 프로그래밍)이란?

스프링 프레임워크의 핵심 3대 요소(IoC, DI, AOP) 중 하나로, 애플리케이션 전반에 걸쳐 반복적으로 등장하는 ‘공통 기능’을 ‘핵심 비즈니스 로직’에서 분리해내는 프로그래밍 패러다임입니다.

쉽게 말해, “비즈니스 로직 앞뒤에 붙여야 하는 반복적인 코드들을 싹 걷어내서 한 곳에서 관리하게 해주는 기술”입니다.

### 1. 왜 AOP가 필요한가?

개발을 하다보면, 핵심 로직과는 상관없지만 반드시 해야 하는 일들이 있습니다.

- 핵심 관심 사항: 주문하기, 회원가입, 계좌이체 등 진짜 비즈니스 로직
- 공통 관심 사항: 로그 남기기, 보안 검사, 트랜잭션 관리, 실행 시간 측정 등 모든 모듈에 공통적으로 적용되어야 하는 기능

AOP가 없다면? 모든 메소드에 똑같은 코드를 반복해서 작성해야 합니다. (코드 중복, 유지보수 쉽지 않음)

```java
// AOP 적용 전: 비즈니스 로직과 부가 기능이 뒤섞임
public void join(User user) {
    // 1. 트랜잭션 시작 (공통)
    transactionManager.begin();

    // 2. 로그 남기기 (공통)
    log.info("회원 가입 시작");

    try {
        // --- 핵심 비즈니스 로직 ---
        userRepository.save(user);
        // -----------------------
    } catch(Exception e) {
        // 3. 롤백 (공통)
        transactionManager.rollback();
        throw e;
    }

    // 4. 커밋 (공통)
    transactionManager.commit();
}
```

AOP를 적용하면? 핵심 로직만 깔끔하게 남습니다.

```java
// AOP 적용 후: 핵심 로직만 존재
@Transactional // <- 이 어노테이션이 AOP를 적용하라는 표시
public void join(User user) {
    userRepository.save(user);
}
```

### 2. Spring AOP의 동작 원리: 프록시 (Proxy)

가장 중요한 부분입니다.

Spring AOP는 소스 코드를 직접 고치는 게 아니라, 프록시라는 가짜 객체를 만들어서 동작합니다.

1. 프록시 생성: Spring은 Bean을 등록할 때, AOP가 적용된 클래스가 있다면 그 클래스를 감싸는 프록시 객체를 몰래 만듭니다.
2. 가로채기: 외부에서 userService.join()을 호출하면, 실제로는 프록시의 join()이 먼저 호출됩니다.
3. 부가 기능 수행: 프록시는 먼저 공통 기능(트랜잭션 시작, 로그 등)을 수행합니다.
4. 실제 객체 호출: 그 다음 실제 UserService 객체의 join()을 호출합니다.
5. 마무리: 실제 객체의 작업이 끝나면, 프록시가 다시 제어권을 받아 마무리 작업(커밋, 로그 종료)을 수행합니다.

## private 메소드에서 @Transactional이 동작하지 않는 원인: 프록시의 한계

Spring은 @Transactional이 선언된 클래스를 빈을 등록할 때, 원본 클래스를 감싸는 가짜 객체를 만듭니다.

1. 외부 호출: 외부에서 메소드를 호출하면, 실제로는 프록시 객체의 메소드가 먼저 호출됩니다.
2. 트랜잭션 시작: 프록시는 @Transactional이 있는지 확인하고, 트랜잭션을 시작(BEGIN)합니다.
3. 실제 호출: 그리고 나서 실제 원본 객체의 메소드를 호출합니다.
4. 트랜잭션 종료: 원본 메소드가 끝나면 프록시가 다시 제어권을 받아 트랜잭션을 커밋하거나 롤백합니다.

여기서 문제가 발생합니다.

- 프록시가 트랜잭션 코드를 끼워 넣으려면, 해당 메소드를 오버라이딩하거나 인터페이스를 통해 접근해야 합니다.
- 하지만 private메소드는 상속이 불가능하고 외부에서 접근할 수도 없습니다.
- 따라서 프록시 객체는 private 메소드를 건드릴 수 없으므로 트랜잭션 기능도 적용할 수 없습니다.

## 자가 호출

private 메소드는 보통 외부에서 직접 부르지 않고, 같은 클래스 내부의 다른 메소드가 호출합니다.

```java
@Service
public class OrderService {

    // 외부에서 이 메서드를 호출함 (트랜잭션 O)
    @Transactional
    public void createOrder() {
        // ... 로직 ...
        updateStock(); // [문제 상황] 내부에서 자신의 private 메서드 호출
    }

    // 여기에 @Transactional을 붙여도 동작 안 함!
    @Transactional
    private void updateStock() {
        // ... DB 작업 ...
    }
}
```

위 코드에서 updateStock()은 트랜잭션이 적용되지 않습니다.

이유는 createOrder() 내부에서 this.updateStock()을 호출할 때는, 프록시를 거치지 않고 원본 객체 내부에서 직접 호출하기 때문입니다.

프록시가 가로챌 기회가 없으므로 트랜잭션 어드바이스가 적용되지 않습니다. (이는 updateStock 이 public이어도 마찬가지입니다.)

## 해결 방법

private 메소드에 트랜잭션을 적용하고 싶다면 구조를 변경해야 합니다.

1. 클래스 분리 (최선의 선택)
   - 해당 메소드를 별도의 서비스 클래스로 분리하고 public으로 만듭니다.
   - 그리고 원래 클래스에서 그 빈을 주입받아 호출합니다. 이렇게 하면 프록시를 통해 호출되므로 트랜잭션이 정상 동작합니다.
2. 메소드를 public으로 변경 (차선책)
   - 메소드를 public으로 바꾸고, 외부에서 호출하도록 로직을 변경합니다. (여전히 내부에서 this.메소드()로 호출하면 안됩니다.)
3. AspectJ 모드 (비추천)
   - Spring의 기본 프록시 방식(AOP) 대신, 컴파일 시점에 바이트코드를 조작하는 AspectJ 위빙 방식을 사용하면 private 메소드에도 트랜잭션을 걸 수 있씁니다.
   - 하지만 설정이 복잡하고 빌드 프로세스가 무거워지므로 특별한 이유가 없다면 권장하지 않습니다.

## 정리

- 결과: private 메소드의 @Transactional은 무시됩니다.
- 이유: Spring 프록시가 private 메소드에 접근하거나 오버라이딩할 수 없기 때문입니다.
- 해결: 트랜잭션이 필요한 로직은 별도의 클래스로 분리하여 public 메소드로 만들고 주입받아 사용합니다.
