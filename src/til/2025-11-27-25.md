---
title: 데이터베이스에서 동시성을 제어하는 방법
description: 데이터베이스 시스템에서 동시성을 제어하는 방법은 무엇이 있을까요?
date: 2025-11-27
tags: [데이터베이스, 동시성, 락, MVCC]
---

데이터베이스 시스템에서 동시성 제어란, 다수의 트랜잭션이 동시에 실행되는 환경에서 데이터의 무결성과 일관성을 보장하기 위해 트랜잭션 간의 상호작용을 제어하는 기법을 말합니다.

동시성 제어가 실패하면 갱신 분실, 더티 리드 등의 치명적인 데이터 오염이 발생합니다. 이를 방지하기 위해 데이터베이스 시스템(DBMS)은 크게 4가지의 핵심 기법을 사용합니다.

## 1. 락 기반 프로토콜 (Lock-Based Protocol)

가장 전통적이고 직관적인 방법입니다. 데이터에 접근하기 전에 잠금(Lock)을 획득하고, 사용 후 해제하는 방식입니다.

### A. 2단계 잠금 규약 (2PL, Two-Phase Locking)

단순히 락을 걸고 푸는 것만으로는 직렬성을 보장하기 어렵습니다. 이를 해결하기 위해 트랜잭션의 락 관리를 두 단계로 엄격하게 나눕니다.

1. 확장 단계: 트랜잭션이 필요한 모든 락을 획득하기만 하고, 절대 해제하지 않는 단계입니다.
2. 축소 단계: 락을 해제하기만 하고, 새로운 락을 획득할 수 없는 단계입니다.

이 규약을 따르면 트랜잭션 간의 충돌을 직렬화할 수 있지만, 교착 상태가 발생할 가능성이 있으며, 동시성이 다소 저하됩니다.

### B. 락의 입도 (Granularity)

락을 거는 범위에 따라 동시성 성능이 달라집니다.

- Row Lock: 행 단위 잠금. 동시성은 높으나 락 관리 오버헤드가 큽니다.
- Table Lock: 테이블 전체 잠금. 관리는 쉬우나 동시성이 매우 낮습니다.
- Page Lock: 데이터 페이지(블록) 단위 잠금. 중간 단계입니다.

## 2. MVCC (Multi-Version Concurrency Control)

현대적인 RDBMS(MySQL, InnoDB, PostgreSQL, Oracle)가 채택하는 가장 대중적이고 효율적인 기법입니다.

- 핵심 아이디어: 락을 걸어 읽기를 차단하는 대신, 데이터의 변경 이력을 별도로 관리합니다.
- 동작
  - 데이터를 갱신할 때, 원본 데이터를 덮어쓰는 것이 아니라 새로운 버전을 생성하고, 기존 데이터는 Undo Log 영역에 유지합니다.
  - 읽기 트랜잭션은 자신의 시작 시점에 맞는 과거 버전의 데이터를 읽습니다.
- 장점: 읽기 작업은 쓰기 작업을 차단하지 않고, 쓰기 작업도 읽기 작업을 차단하지 않습니다. 이로 인해 동시 처리량이 획기적으로 증가합니다.

## 3. 타임스탬프 순서 기법 (Timestamp Ordering Protocol)

시스템이 각 트랜잭션에 고유한 타임스탬프를 부여하여, 트랜잭션 간의 순서를 미리 정해두는 방식입니다.

- 동작
  - 각 데이터(X)마다 `Read_TS(X)`(마지막 읽은 시간)와 `Write_TS(X)`(마지막 쓴 시간)를 기록합니다.
  - 트랜잭션 T가 읽기/쓰기를 시도할 때, 자신의 타임스탬프 TS(T)가 데이터의 타임스탬프보다 오래되었다면(즉, 미래의 트랜잭션이 이미 데이터를 건드렸다면), 트랜잭션 T는 롤백되고 새로운 타임스탬프를 받아 재시작됩니다.
- 특징: 교착 상태(Deadlock)가 원천적으로 발생하지 않지만, 롤백(재시작)이 빈번하게 발생할 수 있습니다.

## 4. 낙관적 동시성 제어 (Optimistic Concurrency Control)

“충돌이 거의 일어나지 않을 것”이라고 가정하고, 락 없이 작업을 수행한 뒤 마지막에 검증하는 방식입니다. 주로 애플리케이션 레벨이나 NoSQL 등에서 활용됩니다.

- 3단계 수행
  1. 판독(Read) 단계: 락 없이 데이터를 읽고, 로컬 메모리에서 자유롭게 수정합니다.
  2. 확인(Validation) 단계: 트랜잭션 종료 시점에, 내가 수정한 데이터가 그사이에 다른 트랜잭션에 의해 변경되었는지 검사합니다.
  3. 기록(Write) 단계: 충돌이 없으면 DB에 반영(Commit)하고, 충돌이 있으면 롤백합니다.
- 장점: 락 유지 비용이 없습니다.
- 단점: 충돌이 잦은 환경에서는 롤백 비용이 커서 성능이 급격히 저하됩니다.

## 실무에서는?

이 기술들이 해결하지 못하는 애플리케이션 레벨의 문제와 서버가 여러 대일 때의 문제로 시야를 넓힙니다.

실무에서는 백엔드 개발자가 반드시 마주치게 될 두 가지 주제인 “갱신 분실 문제”와 “분산 락”에 대해 알아봅니다.

### 1. 갱신 분실 문제 (Lost Update Problem)

데이터베이스의 격리 수준이나 MVCC가 작동하더라도, 애플리케이션 로직의 시점 차이로 인해 발생하는 고전적인 문제입니다.

[시나리오]

두 명의 관리자(A,B)가 동시에 상품의 재고(현재 10개)를 수정하려 합니다.

1. Time 1: 관리자 A가 상품 정보를 조회합니다. (재고: 10)
2. Time 2: 관리자 B가 상품 정보를 조회합니다. (재고 10)
3. Time 3: 관리자 A가 재고를 1개 더해서 11개로 저장합니다. (DB: 11)
4. Time 4: 관리자 B는 아까 본 10개를 기준으로 5개를 더해서 15개로 저장합니다. (DB: 15)

결과: 관리자 A가 수행한 작업(+1)은 관리자 B의 작업에 의해 완전히 덮어씌워져 사라졌습니다. 최종 재고는 16이 되어야 하는데 15가 되었습니다.

[해결책: 애플리케이션 레벨의 락]

데이터베이스는 T3와 T4 시점에 각각 들어온 요청을 정당한 요청으로 보고 처리했을 뿐입니다. 이를 막기 위해 개발자는 두 가지 전략 중 하나를 선택해야 합니다.

- 비관적 락 (Pessimistic Lock / SELECT FOR UPDATE)
  - A가 조회하는 순간(Time 1) 데이터에 배타 락(X-Lock)을 겁니다. B는 A가 저장을 끝낼 때까지 조회조차 못 하고 대기(Blocking)해야 합니다. 데이터 무결성은 완벽하지만 성능이 떨어집니다.
- 낙관적 락 (Optimistic Lock / @Version)
  - 데이터에 version 컬럼을 추가합니다.
  - A가 업데이트 할 때 version이 1에서 2로 바뀝니다.
  - B가 업데이트하려 할 때, WHERE version = 1 조건으로 쿼리를 날립니다. 하지만 이미 버전 2로 바뀌었으므로 수정 대상이 0건이 됩니다.
  - 애플리케이션은 B에게 “누군가 먼저 수정했습니다. 다시 조회하세요”라고 예외를 던집니다.

### 2. 분산 락 (Distributed Lock)

지금까지 이야기 한 동시성 제어(DB Lock, Java synchronized)는 단일 DB, 단일 서버 환경에서만 유효합니다.

만약 서버가 여러 대(Scale-out)이거나, DB가 분리된 MSA 환경이라면 어떻게 동시성을 제어해야 할까요?

자바의 synchronized는 다른 서버에 있는 스레드를 막지 못합니다.

이때 사용하는 기술이 분산 락입니다.

[A. 동작 원리]

여러 서버가 공통으로 바라보는 제 3의 공간(주로 Redis)을 이용하여 락을 관리합니다.

1. 락 획득 시도: 서버 A가 Redis에 “내가 Order:123 자원을 쓸거야”라고 키를 생성합니다.
2. 성공: 키 생성에 성공하면 락을 획득한 것으로 간주하고 작업을 수행합니다.
3. 실패: 서버 B도 동시에 키 생성을 시도했지만, 이미 키가 존재하므로 실패합니다. B는 잠시 대기하거나 포기합니다.
4. 락 해제: 서버 A가 작업을 마치면 Redis에서 해당 키를 삭제합니다.

[B. 대표적인 구현체: Redisson (Redis)]

Java-Spring Boot에서는 Redis 클라이언트 라이브러리인 Redisson을 가장 많이 사용합니다.

- 스핀 락 방지: 락을 얻을 때까지 무한루프를 돌며 Redis에 부하를 주는 방식 대신, Pub/Sub 방식을 사용하여 락이 해제되었을 때 알림을 받아 효율적입니다.
- 타임아웃: 락을 획득한 서버가 갑자기 죽어서 락을 영원히 해제하지 못하는 경우를 대비해, TTL을 설정하여 일정 시간이 지나면 락이 자동으로 풀리도록 안전장치를 둡니다.
