---
title: 자바의 Checked Exception과 Unchecked Exception
description: 자바에서 Checked Exception과 Unchecked Exception은 무엇일까요?
date: 2025-11-01
tags: [Spring Boot, Java, Checed Exception, Unchecked Exception]
---

# Checked Exception과 Unchecked Exception 개념 설명

| 구분                | Checked Exception                                | Unchecked Exception                                                            |
| ------------------- | ------------------------------------------------ | ------------------------------------------------------------------------------ |
| 상속 계층           | Exception (단, RuntimeException 제외)            | RuntimeException 및 그 하위 클래스                                             |
| 예외 처리 강제 여부 | 컴파일 시점에 try-catch 또는 throws 강제         | 강제되지 않음                                                                  |
| 예시                | IOException, SQLException, FileNotFoundException | NullPointerException, IllegalArgumentException, ArrayIndexOutOfBoundsException |
| 발생 시점           | 컴파일 타임에 감지 가능                          | 런타임 시점에 발생                                                             |
| 목적                | 예측 가능한 외부 요인(I/O, 네트워크 등)          | 프로그래밍 오류나 논리적 실수                                                  |

# 동작 원리

## Checked Exception

Checked Exception은 컴파일 타이밍에 반드시 처리해야 하는 예외입니다.

즉, try-catch로 직접 처리하고 throws로 위임하지 않으면 컴파일 에러가 발생합니다.

주로 외부 환경 요인으로 인해 예측 가능한 예외 상황에서 발생합니다.

```java
public void readFile(String path) throws IOException {
    FileReader reader = new FileReader(path); // Checked Exception
    reader.read();
}
```

이 경우, IOException은 파일이 없거나 접근 불가능한 상황처럼 개발자가 제어할 수 없는 외부 요인이므로 명시적으로 예외를 처리해야 합니다.

## Unchecked Exception

Unchecked Exception은 런타임에 발생할 수 있는 예외입니다.

컴파일러가 예외를 강제하지 않습니다.

주로 프로그래밍 로직의 실수, 개발자의 부주의로 인해 발생합니다.

```java
public void divide(int a, int b) {
    int result = a / b; // b가 0이면 ArithmeticException 발생
}
```

이 예외는 개발자가 입력 검증을 통해 미리 방지할 수 있기 때문에, Checked로 강제하지 않습니다. (개발자의 책임)

# 왜 이런 구분이 생겼을까?

Java는 안정성을 극대화 하기 위해 Checked Exception을 도입했습니다.

C나 C++처럼 그냥 프로그램이 터지는 대신, 예외가 발생할 수 있음을 명시적으로 알리고 처리하도록 강제한 것입니다.

하지만 실제 대규모 프로젝트에서는 너무 많은 Checked Exception 처리로 코드가 복잡해지고, 불필요한 try-catch 블록이 남발되면서 가독성과 유지보수성이 떨어졌습니다.

그래서 Spring, JPA, JDBC 템플릿 같은 대부분의 현대 프레임워크는 Checked Exception을 거의 Unchecked로 감쌉니다.

예를 들어

```java
try {
    connection.prepareStatement(sql);
} catch (SQLException e) {
    throw new DataAccessException(e); // Unchecked로 변환
}
```

이게 바로 Checked → Unchecked 변환 패턴입니다.

# Spring 에서는 왜 Checked Exception을 거의 쓰지 않을까?

## 이유 1. Checked Exception은 복구 가능한 상황에서만 의미가 있다.

Checked Exception의 철학은 “개발자가 이 예외를 복구할 수 있는가?” 입니다.

예외가 발생했을 때 재시도를 한다거나, 다른 경로로 시도하거나, 기본값으로 대체할 수 있다면? Checked Exception이 맞습니다.

하지만 Spring이 다루는 대부분의 예외는 복구가 불가능한 상황입니다.

예를 들어

SQLException → DB 연결이 끊겼는데 애플리케이션 코드에서 복구 불가

IOException → 네트워크 장애 발생 시 재시도보다 서버 로직 중단이 합리적

MalformedURLException → 코드 실수로 URL이 잘못됨 (개발자 오류)

이런 예외들은 복구보다는 로깅하고 상위 계층에 전달하는게 맞습니다.

그런데 Checked Exception은 이를 매번 try-catch로 감싸야 해서 불필요하게 코드가 지저분해집니다.

## 이유 2. Checked Exception은 계층 간 전파가 어렵다.

Spring 애플리케이션은 다층 구조 (Controller → Service → Repository)로 되어있씁니다.

예를 들어 Repository 계층에서 DB 오류가 발생했다고 가정하면

```java
public User findUser(Long id) throws SQLException {
    ...
}
```

이 예외를 Service, Controller까지 throws로 계속 던져야합니다.

하지만 Controller 계층에서는 DB 예외에 대해 아무런 복구 로직이 없습니다.

상위 계층으로 전파할수록 Checked Exception의 의미가 사라집니다.

Spring은 이를 해결하기 위해 SQLException을 DataAccessException (RuntimeException)으로 변환 했습니다.

결과적으로 불필요한 throws가 제거되고 비즈니스 로직에 집중이 가능해졌습니다. 그리고 트랜잭션 롤백도 RuntimeException이면 자동으로 처리됩니다. (@Transactional 기본 정책)

## 이유 3. AOP, 트랜잭션 관리와 잘 맞는다.

Spring의 트랜잭션 관리자는 기본적으로 RuntimeException 또는 Error가 발생했을 때 자동으로 롤백합니다.

만약 Checked Exception이 발생한다면? 명시적으로 rollbackFor = Exception.class 설정을 해줘야 합니다.

```java
@Transactional(rollbackFor = Exception.class)
public void serviceMethod() throws Exception {
    ...
}
```

Checked Exception은 AOP 기반 트랜잭션 처리와 궁합이 좋지 않습니다.

그래서 Spring은 자연스럽게 Unchecked 중심의 예외 계층 구조를 채택하게 되었습니다.

## 이유 4. 코드 가독성과 유지보수성

try-catch 블록 남발은 코드의 가독성을 떨어뜨리고, 핵심 비즈니스 로직이 예외 처리 코드에 묻혀버립니다.

Spring은 이런 boilerplate를 최소화 하기 위해

AOP 기반 전역 예외 처리 (@ControllerAdvice, @ExceptionHandler)와 RuntimeException 기반 전파 구조를 선호합니다.

# Checked Exception을 Unchecked로 감싸는 패턴의 장단점

Spring은 대표적으로 SQLException → DataAccessException으로 변환하는 예외 래핑(Exception Wrapping) 전략을 씁니다.

## 장점

### 1. 비즈니스 로직 단순화

Checked Exception은 반드시 throws나 try-catch를 작성해야 하지만, Unchecked Exception은 이런 강제가 없습니다.

```java
try {
    repository.save(user);
} catch (SQLException e) {
    throw new DataAccessException(e);
}
```

위 과정을 한 번만 처리해두면, Service/Controller 계층에서는 더 이상 신경 쓸 필요가 없습니다.

### 2. 계층 간 결합도 낮춤

Repository 계층에서 발생한 DB 예외는 Service 계층이 몰라도 되는 세부 구현입니다.

DataAccessException은 DB 종류에 상관없이 추상화된 예외 계층이라, DB를 바꿔도 비즈니스 코드에는 영향을 주지 않습니다.

### 3. 트랜잭션 처리와 자연스럽게 연동

RuntimeException이 발생하면 자동으로 롤백이 이루어집니다.

Checked Exception보다 훨씬 자연스럽고 실용적입니다.

### 4. 전역 예외 처리와 잘 맞음

Spring MVC의 @ControllerAdvice나 전역 예외 핸들러에서는 RuntimeException 기반의 전파 구조가 훨씬 단순합니다.

예외 흐름이 깔끔하고, 애플리케이션 전체 예외 정책을 통합 관리할 수 있습니다.

## 단점

### 1. 예외가 발생할 수 있음을 컴파일 타임에 인지하지 못한다

Checked Exception의 장점은 명시적인 예외 처리 강제인데, Unchecked로 바꾸면 이런 명시성이 사라집니다.

### 2. 예외 복수를 의도한 경우엔 오히려 위험

정말로 복구 가능한 예외는 Unchecked로 두면 예외를 놓칠 수 있습니다.

이런 경우엔 Checked Exception을 쓰는게 더 적절합니다.

### 3. 모든 예외가 RuntimeException이면 디버깅이 어려워질 수 있다.

예외 구분이 약해지고, 무조건 런타임 예외로 던져버리면 예외 원인 추적이나 책임 구분이 어려워질 수 있습니다.

# 정리

Spring에서는 대부분의 예외가 “복구 불가능하고, 단순히 상위 계층으로 전달되어야 하는 상황”이기 때문에 Checked Exception보다 Unchecked Exception을 선호합니다.

따라서 Checked Exception을 Unchecked로 감싸는 패턴은 비즈니스 로직 단순화, 계층 간 결합도 감소, 트랜잭션 자동 롤백 측면에서 큰 장점을 가지지만, 반대로 명시적 예외 처리 의도나 복구 로직이 필요한 경우엔 신중하게 사용해야 합니다.
