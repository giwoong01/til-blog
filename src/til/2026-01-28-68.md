---
title: CSRF 공격
description: CSRF 공격은 무엇인가요?
date: 2026-01-28
tags: [CSRF]
---

CSRF(Cross-Site Request Forgery, 사이트 간 요청 위조)는 사용자가 자신의 의지와는 무관하게 공격자가 의도한 행위(수정, 삭제, 등록 등)를 특정 웹사이트에 요청하게 만드는 공격입니다.

쉽게 비유하자면, “사용자의 ‘로그인 된 상태’를 도용해서 몰래 결제 버튼을 누르게 만드는 것”과 같습니다.

## 1. 공격의 핵심 원리

이 공격이 가능한 이유는 웹 브라우저의 특성 때문입니다. 브라우저는 특정 도메인으로 요청을 보낼 때, 그 도메인과 관련된 쿠키(세션 ID 등)를 자동으로 함께 실어서 보냅니다.

서버 입장에서는 요청에 올바른 쿠키가 들어있으니, “아, 이 요청은 정당한 사용자가 보낸 것이구나”라고 착각하고 요청을 처리해 버립니다.

## 2. 공격 시나리오

사용자가 A 은행 사이트에 로그인해 있는 상태라고 가정해 봅시다.

1. 해커의 준비: 해커는 자신의 웹사이트 (또는 이메일)에 다음과 같은 숨겨진 이미지 태그를 심어놓습니다.

   ```html
   <img
     src="http://bank.com/transfer?to=hacker&amount=1000000"
     width="0"
     height="0"
   />
   ```

   실제로는 <img> 태그는 GET 요청만 가능하므로, POST 요청이 필요한 경우엔 자바스크립트로 폼을 자동 전송하게 만듭니다.

2. 사용자의 방문: 사용자가 (은행 사이트에 로그인된 채로) 해커의 사이트에 접속하거나 이메일을 엽니다.
3. 자동 실행: 브라우저는 위 <img> 태그를 보고 bank.com 으로 요청을 보냅니다. 이때 사용자의 A 은행 로그인 쿠키가 자동으로 함께 전송됩니다.
4. 피해 발생: A 은행 서버는 유효한 쿠키가 있으니 정상적인 이체 요청으로 판단하고, 해커의 계좌로 돈을 이체해 버립니다.

## 3. 방어 방법

CSRF를 막기 위해서는 “이 요청이 진짜 우리 사이트 화면에서 사용자가 누른 것인지”를 검증해야 합니다.

1. CSRF Token 사용

서버는 사용자가 페이지를 요청할 때, 임의의 난수값인 CSRF Token을 생성하여 세션에 저장하고, HTML 폼에도 숨겨진 필드로 내려보냅니다.

```html
<form action="/transfer" method="POST">
  <input type="hidden" name="_csrf" value="a1b2c3d4..." />
  ...
</form>
```

- 방어 원리: 사용자가 버튼을 누르면 이 토큰값이 같이 서버로 전송됩니다. 해커는 사용자의 세션에 저장된 이 토큰값을 알 수 없으므로(SOP 정책 때문), 위조된 요청에는 토큰이 없거나 틀려서 서버가 거부합니다.

1. SameSite 쿠키 속성 설정

쿠키를 설정할 때 SameSite 속성을 사용하여, “다른 사이트에서 보내는 요청에는 쿠키를 절대 실어 보내지 마라”고 브라우저에게 지시합니다.

- `SameSite=Strict`: 같은 도메인 요청에서만 쿠키 전송 (가장 강력)
- `SameSite=Lax`: 안전한 요청(GET 등)인 경우에만 예외적으로 전송 (사용성 고려, 최신 브라우저 기본값)

1. Referer 검증

요청 헤더에 있는 Referer 값을 확인하여, 이 요청이 우리 도메인에서 온 것인지 확인합니다. (보조적인 수단으로 사용)

## 정리

- CSRF: “나도모르게 내 계정으로 글이 써지거나 돈이 이체되는 공격”
- 원인: 브라우저가 쿠키를 자동으로 보내주기 때문
- 해결: CSRF Token을 사용하여 요청의 출처를 확실히 검증해야 함.
