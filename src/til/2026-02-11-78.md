---
title: CQRS
description: CQRS 패턴이란 무엇인가요?
date: 2026-02-11
tags: [CQRS]
---

CQRS(Command and Query Responsibility Segregation)는 시스템에서 명령을 처리하는 책임과 조회를 처리하는 책임을 명확히 분리하는 아키텍처 패턴입니다.

전통적인 CRUD 모델이 하나의 데이터 모델로 읽기와 쓰기를 모두 처리하는 것과 달리, CQRS는 이 둘을 나누어 성능, 확장성, 보안을 최적화합니다.

## 1. 개념: 명령과 조회 분리

CQRS는 애플리케이션을 두 개의 파트로 나눕니다.

1. 명령 (Command) - Write Side

- 역할: 시스템의 상태를 변경하는 작업 (Create, Update, Delete)
- 특징
  - 데이터의 유효성 검사와 복잡한 도메인 로직 처리에 집중합니다.
  - 일반적으로 값을 반환하지 않거나, 성공/실패 여부 정도만 반환합니다.
  - “데이터를 어떻게 저장할 것인가”에 최적화되어 있습니다. (정규화된 RDBMS)

1. 조회 (Query) - Read Side

- 역할: 시스템의 상태를 반환하는 작업 (Read)
- 특징
  - 상태를 변경하지 않으며, 오직 데이터를 보여주는 데 집중합니다.
  - 복잡한 로직 없이 화면에 보여줄 형태(DTO)로 데이터를 빠르게 가져오는 것이 목표입니다.
  - “데이터를 어떻게 보여줄 것인가”에 최적화되어 있습니다.

## 2. 데이터베이스 분리

CQRS를 단순히 코드 레벨에서만 적용할 수도 있지만, 많은 경우 데이터 저장소까지 물리적으로 분리하여 효과를 극대화합니다.

1. 쓰기 DB (Command Store)
   - 데이터 무결성이 중요하므로 주로 RDBMS(MySQL, PostgreSQL)를 사용합니다.
   - 정규화된 설계를 유지합니다.
2. 읽기 DB (Query Store)
   - 조회 성능이 중요하므로 NoSQL이나 검색 엔진을 사용하기도 합니다.
   - 조회 화면에 딱 맞는 형태로 데이터를 미리 뭉쳐놓는 비정규화 설계를 합니다.

[동기화 문제]

쓰기 DB와 읽기 DB가 나뉘면 데이터가 일치하지 않는 순간이 발생합니다. 이를 맞추기 위해 이벤트 소싱이나 메시지 큐를 사용하여, 쓰기 DB의 변경 사항을 비동기적으로 읽기 DB에 반영합니다.

이로 인해 결과적 일관성이 발생합니다.

## 3. 장단점

### 장점

- 성능 최적화: 읽기 작업과 쓰기 작업의 부하가 다를 때(보통 읽기가 훨씬 많음), 읽기용 서버/DB만 따로 스케일 아웃하여 확장하기 유리합니다.
- 단순화된 모델: 쓰기 모델은 도메인 로직에만, 읽기 모델은 화면 출력에만 집중하므로 각자의 코드가 깔끔해집니다.
- 장애 격리: 읽기 DB에 장애가 발생해도, 쓰기 기능은 정상 작동하게 할 수 있습니다.

### 단점

- 구현 복잡도 증가: 시스템 구조가 훨씬 복잡해집니다. 별도의 동기화 로직과 인프라가 필요합니다.
- 데이터 지연: 쓰기 DB에서 읽기 DB로 데이터가 넘어가는 데 시간이 걸리므로, 실시간성이 매우 중요한 서비스에는 주의가 필요합니다.

## 정리

- 기존: 하나의 모델/DB로 읽고 쓰기를 다 함.
- CQRS: “쓰는 놈”과 “읽는 놈”을 분리하자
- 목적: 읽기 성능을 극한으로 끌어올리고, 도메인 로직을 단순하게 유지하기 위함.
