---
title: Spring Data JPA에서 새로운 Entity인지 판단하는 방법
description: Spring Data JPA에서 새로운 Entity인지 판단하는 방법은 무엇일까요?
date: 2025-10-27
tags: [Spring Boot, JPA, Entity, Java]
---

Spring Data JPA에서 Entity가 "새로운 객체(new)"인지, 기존에 존재하는 객체(즉, DB에 이미 있는 row)인지를 판단하는 기준은 꽤 명확합니다.

결론부터 말하면... Spring Data JPA는 식별자(@Id) 필드 값으로 판단합니다.

# 기본 규칙

Spring Data JPA의 Save() 메소드는 내부적으로 아래 로직을 수행합니다.

```java
if (entityInformation.isNew(entity)) {
    em.persist(entity);
} else {
    em.merge(entity);
}
```

이 Entity가 새로운 객체인지 아닌지를 판단하는 핵심은 `entityInformation.isNew(Entity)` 메소드의 결과입니다.

## isNew()의 판단 기준

Spring Data JPA는 JPAEntityInformation 인터페이스의 구현체를 통해 엔티티의 식별자(@Id)를 보고 새 엔티티인지 판별합니다.

- @Id가 null이면 -> 새로운 Entity (new)
  - em.persist(entity) 실행
- @Id가 존재하면 -> 이미 존재하는 엔티티 (existing)
  - em.merge(entity) 실행

@id 필드가 null인지 아닌지가 기준입니다.

```java
@Entity
public class User {
    @Id
    @GeneratedValue
    private Long id;
    private String name;
}
```

```java
User u1 = new User();
u1.setName("Alice");
userRepository.save(u1);  // id == null → persist()

User u2 = userRepository.findById(1L).get();
u2.setName("Bob");
userRepository.save(u2);  // id != null → merge()
```

# 예외

하지만 예외도 있습니다.

1. 식별자를 직접 할당(@GeneratedValue 안 쓰는 경우)

이때는 id != null 이라도 "DB에 없는 값"일 수 있습니다.

-> JPA는 실제 DB 조회 없이 merge()를 시도하기 때문에, "비효율적인 update 쿼리"가 나올 수 있습니다.

2. Persistable 인터페이스를 구현한 경우

Spring Data JPA는 이 인터페이스를 인식해서 개발자가 직접 새로운 객체인지 여부를 정의할 수 있도록 지원합니다.

```java
@Entity
public class User implements Persistable<String> {
    @Id
    private String id;
    private String name;

    @Transient
    private boolean isNew = true;

    @Override
    public String getId() {
        return id;
    }

    @Override
    public boolean isNew() {
        return isNew;
    }
}
```

이렇게 하면, id 값이 있어도 isNew()가 true면 persist()를 수행하게 됩니다.
즉, 비식별자 생성 전략을 쓰는 도메인에서 새 객체 판별 문제를 직접 제어할 수 있게됩니다.

# 정리

Spring Data JPA는 기본적으로 @Id 필드가 null이면 새로운 엔티티로 간주하지만, Persistable 인터페이스를 구현하면 직접 '새로운 객체'판별 로직을 정의할 수 있습니다.
