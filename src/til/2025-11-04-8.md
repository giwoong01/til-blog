---
title: 데이터베이스 인덱스
description: 데이터베이스 인덱스는 무엇이며, 시나리오로 함께 봅시다.
date: 2025-11-04
tags: [데이터베이스, 인덱스, 실행 계획, 옵티마이저]
---

# 인덱스(index)란?

인덱스란 추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상 시키기 위한 자료구조입니다.

쉽게 말하면 책의 목차와 같습니다.

책의 모든 페이지를 다 읽는 대신, “찾고 싶은 단어가 몇 쪽에 있는지”를 목차(index)에서 빠르게 찾아갑니다.

이 덕분에 전체 테이블 스캔(Full Table Scan)을 하지 않고도 일부 데이터만 빠르게 조회할 수 있습니다.

## 비유

가장 보편적인 비유는 “책의 색인” 입니다. 수백 페이지 분량의 책에서 특정 키워드(예: ‘B-Tree’)를 찾는다고 가정해 보겠습니다.

- 인덱스가 없는 경우 (Full Table Scan): 책의 첫 페이지부터 마지막 페이지까지 모든 단어를 순차적으로 읽어봐야 합니다. 이는 데이터베이스에서 Full Table Scan (테이블 전체 스캔)에 해당하며, 데이터의 양(N)에 비레하는 O(N)의 시간 복잡도를 가집니다.
- 인덱스가 있는 경우 (Index Scan): 책의 맨 뒤에 있는 ‘색인’을 봅니다. ‘B’ 섹션으로 이동하여 ‘B-Tree’항목을 찾으면, 해당 키워드가 120, 250, 310페이지에 있다고 즉시 알려줍니다. 이 색인 페이지만 참조하여 원하는 데이터가 있는 실제 페이지(데이터 블록)로 바로 이동할 수 있습니다.

이와 같이, 인덱스는 특정 ‘키(key)’ 값(예: user_id, email)과 해당 키를 포함하는 레코드(Row)의 물리적 주소(e.g., RowID 또는 페이지 번호)를 매핑하는 정보로 구성됩니다.

## 인덱스의 핵심 작동 원리: B+Tree

대부분의 현대 관계형 데이터베이스(RDBMS)는 인덱스 구현을 위해 B+Tree 자료구조를 표준으로 사용합니다.

B-Tree(Balanced Tree)의 변형인 B+Tree는 대용량 디스크 기반 데이터베이스 검색에 최적화 되어있습니다.

### B+Tree의 주요 특징

1. 균형 트리 (Balanced): 루트 노드에서 모든 리프 노드까지의 경로 길이가 동일합니다. 어떤 값을 검색하든 항상 일관된, 예측 가능한 검색 시간(주로 O(logN))을 보장합니다.
2. 데이터 저장 방식: B-Tree와 달리 B+Tree는 모든 데이터 포인터(실제 데이터 행을 가리키는 주소)를 리프노드에만 저장합니다. 루트 및 중간 노드는 오직 키 값과 자식 노드를 가리키는 포인터(경로 탐색용)만 가집니다.
3. 순차적 접근 (Sequential Access): B+Tree의 가장 중요한 특징은 모든 리프 노드가 양방향 연결 리스트(Linked List)로 연결되어 있다는 점입니다.

### B+Tree가 효율적인 이유

- 탐색 효율성(O(logN)): 데이터가 10억 건이라도, 트리의 높이가 4~5 수준밖에 안합니다. 즉, 4~5번의 디스크 I/O만으로 원하는 데이터를 찾을 수 있습니다. Full Table Scan이 10억 개의 레코드를 모드 읽는 것과 비교할 수 없는 속도입니다.
- 범위 검색(Range Scan) 최적화: 리프 노드가 연결 리스트로 이어져 있기 때문에, `WHERE age BETWEEN 30 AND 40` 과 같은 범위 쿼리에서 매우 효율적입니다. B-Tree를 타서 ‘30’이 있는 리프 노드를 찾은 다음, 연결 리스트를 따라 ‘40’이 나올 때까지 순차적으로 스캔하면 됩니다.

## 인덱스의 유형

### 클러스터형 인덱스 (Clustered Index)

테이블의 데이터 행 자체를 인덱스 키의 순서대로 물리적으로 정렬하여 저장하는 방식입니다. 비유하자면 영어 사전 그 자체입니다. ‘Apple’이라는 단어는 ‘Banana’보다 물리적으로 앞 페이지에 존재합니다.

테이블당 오직 하나만 존재합니다. 일반적으로는 테이블의 기본 키(Primary Key)에 대해 자동으로 생성됩니다. 그리고 인덱스의 리프 노드가 곧 실제 데이터 블록입니다. 그래서 인덱스 탐색 후 별도의 데이터 조회가 필요 없어 매우 빠릅니다.

### 비클러스터형 인덱스 (Non-Clustered Index)

실제 데이터 행의 물리적 순서와는 무관하게, 별도의 공간에 인덱스 키와 데이터 주소(RowID or Clustered Key 값)를 저장하는 방식입니다.

테이블당 여러개를 생성할 수 있습니다. 예를 들어 email 컬럼 인덱스, name 컬럼 인덱스 등

인덱스 탐색 후, 리프 노드에 저장된 주소를 사용하여 실제 데이터 테이블에 한 번 더 접근해야 합니다. (Clustered Index 보다 한 단계 더 필요합니다.)

### 복합 인덱스 (Composite Index)

두 개 이상의 컬럼을 조합하여 생성하는 인덱스입니다.

예를 들어, (last_name, first_name) 과 같습니다.

인덱스 컬럼의 순서가 매우 중요하며, `WHERE last_name = 'Kim' AND first_name = 'Chulsoo'` 같은 쿼리에 효율적입니다.

### 커버링 인덱스 (Covering Index)

쿼리가 필요로 하는 모든 컬럼이 인덱스 자체에 포함되어 있는 경우입니다.

`SELECT name FROM users WHERE name = 'woong'` 와 같습니다.

데이터베이스는 실제 테이블에 접근할 필요 없이 인덱스만 읽고 결과를 반환하므로 성능이 좋습니다.

## 인덱스의 장단점

인덱스는 모든 상황에서 좋은게 아니며, 명확한 트레이드오프가 필요합니다.

### 장점

1. 압도적인 검색(SELECT) 속도 향상: WHERE 절이나 JOIN 조건, ORDER BY 절을 사용한 쿼리의 성능을 O(N)에서 O(logN)으로 개선합니다.

### 단점

1. 저장 공간 오버헤드

   - 인덱스는 원본 데이터와 별개인 B+Tree 자료구조를 유지하기 위한 추가적인 디스크 공간을 소모합니다.

   테이블 크기의 약 5~10% 이상을 차지할 수 있으며, 인덱스가 많을수록 이 공간은 커집니다.

2. 쓰기(Write) 성능 저하 (INSERT, UPDATE, DELETE)
   - 이것이 인덱스 사용의 가장 큰 비용입니다.
   - INSERT: 새로운 데이터가 삽입 될 때, 테이블뿐만 아니라 해당 테이블에 연결된 모든 인덱스의 B+Tree에도 새로운 키 값을 삽입해야 합니다. 이 과정에서 B+Tree의 균형을 맞추기 위한 연산(페이지 분할 등)이 발생할 수 있습니다.
   - DELETE: 데이터 삭제 시, 테이블과 모든 인덱스에서 해당 키 값을 찾아 삭제해야 합니다.
   - UPDATE: 만약 인덱스가 걸린 컬럼의 값이 변경된다면(예: email 변경), 인덱스에서 기존 값을 삭제하고 새로운 값을 삽입하는 복잡한 연산이 발생합니다. (인덱스가 없는 컬럼을 UPDATE하는 것은 비용이 적습니다.)

## 인덱스 설계 시 고려사항

조회 속도가 빨라진다고 무분별한 인덱스 생성은 오히려 시스템 전체의 성능을 저하시킵니다.

1. 카디널리티 (Cardinality):
   - 인덱스 설계의 가장 중요한 원칙입니다. 카디널리티는 ‘특정 컬럼의 중복도를 제외한 유니크한 값의 개수’를 의미합니다.
   - 카디널리티가 높은 컬럼: `user_id`, `email`, `jumin_no` 처럼 값의 대부분이 unique한 컬럼입니다. 인덱스의 효율이 극대화됩니다.
   - 카디널리티가 낮은 컬럼: `gender(M, F)`, `status(Active, Inactive)` 처럼 값이 몇 종류 없는 컬럼입니다. 이러한 인덱스를 생성하면 오히려 성능이 저하됩니다. (예: M을 인덱스에서 찾아도, 전체 데이터의 50%에 접근해야 하므로 차라리 Full Table Scan이 빠름)
2. 쿼리 선택도 (Selectivity):
   - 특정 조건으로 쿼리했을 때 결과로 반환되는 레코드의 비율입니다. (예: 100만 건 중 10건 반환 → 선택도 0.001%)
   - 선택도가 낮을수록(더 작은 데이터를 식별할수록) 인덱스의 효율이 높습니다.
3. 읽기(Read) vs 쓰기(Write) 비율:
   - SELECT가 압도적으로 많고 INSERT/UPDATE가 적은 시스템(데이터 분석, 검색 포털)은 인덱스를 적극적으로 활용하는 것이 좋습니다.
   - INSERT/UPDATE가 매우 빈번한 시스템(예: 실시간 로그 수집, IoT 데이터)은 인덱스 생성을 최소화해야 합니다.

# 실행 계획 (Execution Plan) 과 옵티마이저 (Optimizer)

이론적으로 인덱스가 존재하더라도, 데이터베이스가 그 인덱스를 사용하지 않기로 결정할 수 있습니다.

이 결정을 내려주는 주체가 바로 쿼리 옵티마이저입니다. 옵티마이저가 세운 쿼리 실행 전략을 시각화한 것이 실행 계획입니다.

- EXPLAIN(또는 EXPLAIN ANALYZE): 개발자가 반드시 알아야 할 명령어입니다. SELECT 쿼리 앞에 이 키워드를 붙이면 ,해당 쿼리를 실행하기 위해 데이터베이스가 어떤 인덱스를 사용할 것인지(혹은 Full Table Scan을 할 것인지), 테이블 조인 순서는 어떻게 되는지 등을 보여줍니다.
- 옵티마이저의 판단: 옵티마이저는 테이블의 통계 정보(데이터 분포, 카디널리티, 레코드 수 등)를 기반으로 비용을 계산합니다. 만약 인덱스를 사용하는 비용(Index Scan)이 테이블 전체를 읽는 비용(Full Table Scan)보다 비싸다고 판단하면, 인덱스가 존재함에도 불구하고 Full Table Scan을 수행합니다.

## 예상 시나리오 (테이블 및 인덱스 설정)

먼저 테스트용으로 테이블과 인덱스를 생성합니다.

```sql
-- 사용자 테이블 생성
DROP TABLE IF EXISTS users;
CREATE TABLE users (
	id INT AUTO_INCREMENT PRIMARY KEY,
	username VARCHAR(100) NOT NULL,
	status VARCHAR(20) NOT NULL,
	join_date DATE
);

-- username 컬럼과 status 컬럼에 각각 인덱스 생성
CREATE INDEX idx_users_username ON users (username);
CREATE INDEX idx_users_status ON users (status);

-- 데이터 삽입 - 'ACITVE' 상태의 사용자를 99,000명 삽입
INSERT INTO users(username, status, join_date)
WITH RECURSIVE ns (n) AS (
  SELECT 1 AS n
  UNION ALL
  SELECT n + 1 FROM ns WHERE n < 99000
)
SELECT
    CONCAT('user_', n),
    'ACTIVE',
    DATE('2025-01-01')
FROM ns;

-- 'INACTIVE' 상태의 사용자를 1,000명 삽입
INSERT INTO users(username, status, join_date)
WITH RECURSIVE ns2 (n) AS (
  SELECT 1 AS n
  UNION ALL
  SELECT n + 1 FROM ns2 WHERE n < 1000
)
SELECT
    CONCAT('inactive_user_', n),
    'INACTIVE',
    DATE('2025-01-01')
FROM ns2;

-- 데이터베이스 통계 정보 갱신
ANALYZE TABLE users;
```

총 10만개의 데이터를 생성했습니다.

## 실험: 데이터의 99%를 조회

이 실험은 Full Table Scan을 유도합니다.

```sql
EXPLAIN SELECT * FROM users WHERE status = 'ACTIVE';
```

> 🤖 Gemini의 예상
>
> 이 쿼리는 `idx_users_status` 인덱스가 존재함에도 불구하고, 옵티마이저가 'Full Table Scan' (`type: ALL`)을 선택할 확률이 매우 높습니다.
>
> - **이유:** 옵티마이저는 '인덱스를 사용해서 `ACTIVE` 키를 찾은 뒤, 거기 연결된 99,000개의 데이터 주소로 실제 테이블에 99,000번 접근하는 비용'이, '그냥 테이블 전체(100,000건)를 한 번 순차적으로 훑는 비용'보다 **더 비싸다**고 판단할 것입니다.

Gemini는 이와 같이 예상했습니다. 하지만 제 MySQL(8.0.21)에서 실제로 실행해보면 어떨까요?

![image.png](/images/til/2025-11-04-8/1.png)

보이시나요?

중요한 부분을 보자면 type이 ref입니다.

왜 AI의 예측과 제 실제 실행 결과가 다를까요?

옵티마이저가 이 결정을 내린 이유는, 두 가지 시나리오 (Full Table Scan VS Index Scan)의 예상 비용을 계산해 본 결과 Index Scan이 더 저렴하다고 판단했기 때문입니다.

EXPLAIN 결과에 나온 핵심 증거는 이와 같습니다.

1. type: ref
   - 인덱스 스캔을 했다는 증거입니다.
   - type : ALL (Full Table Scan)이 아닌 ref가 나왔다는 것은, 옵티마이저가 인덱스를 활용해 특정 값과 일치하는 레코드를 효율적으로 찾았다는 의미입니다.
2. key: idx_users_status
   - 해당 인덱스를 사용했다는 의미입니다.
   - 옵티마이저는 idx_users_status 인덱스를 사용하는 것이 key: NULL(인덱스 안 씀) 보다 효율적이라고 결정했습니다.
3. rows: 49194
   - 왜 그렇게 결정했는지에 대한 핵심 근거(수치)입니다.
   - 이는 옵티마이저의 예상치입니다. 옵티마이저가 DB 통계 정보를 바탕으로 “이 쿼리를 실행하면 약 49,194건의 데이터가 반환될 것이다”라고 예측한 것입니다.
4. ref: const
   - WHERE status = ‘ACTIVE’에서 ‘ACTIVE’라는 조회 조건 값이 상수로 사용되어 인덱스 키와 비교되었다는 의미입니다.

## 실험에 대한 의문

여기서 의문이 하나 있습니다.

‘ACTIVE’는 99000개인데 왜 49194건을 예상했을까요?

이게 바로 옵티마이저 통계 정보의 핵심이자 맹점입니다.

EXPLAIN의 rows 컬럼은 쿼리 실행 후의 실제 결과 건수가 아닙니다.

이것은 쿼리를 실행하기 전에 옵티마이저가 가지고 있는 통계 정보를 바탕으로 “이 쿼리를 실행하면 아마 이 정도의 행이 반환될 것이다”라고 추정한 값입니다.

### 1. 통계 정보는 어떻게 만들어지는가? (표본 조사)

시나리오의 마지막에 실행한 `ANALYZE TABLE users;` 명령이 바로 이 통계 정보를 갱신하는 명령입니다.

옵티마이저가 통계 정보를 만들 때, 100,000건의 데이터를 하나하나 다 읽어서 “ACTIVE가 정확히 99,000개, INACTIVE가 1,000개 있다.”라고 100% 정확하게 계산하지 않습니다.

대신 표본 조사를 합니다.

- users 테이블의 데이터 페이지(블록) 중 일부 페이지만 무작위로 읽습니다.
- “A페이지를 보니 ACTIVE가 90%, B페이지는 85%”
- 이 표본을 바탕으로 idx_users_status 인덱스의 ‘ACTIVE’키 값은 전체 데이터의 약 50% 정도를 차지할 것 같다는 추정을 하게됩니다.
- 그래서 전체 100,000건의 50% 정도인 49194라는 추정치를 내놓은 것입니다.

### 2. 왜 추정이 50%나 빗나갔나? (데이터 편중)

ACTIVE는 99%인데 왜 50%로 추정했을까요?

이는 제가 만든 데이터가 극도로 편중되어 있기 때문입니다. 이러한 극단적인 데이터 분포는 표본 조사 방식으로는 정확하게 추정하기 어렵습니다.

옵티마이저의 샘플링 알고리즘이 이런 극단적인 분포를 잘못해석하여 대충 절반 정도 되겠구나 하고 부정확한 통계 정보를 생성한 것입니다.

## 실험 결론

옵티마이저는 실제 99,000건이라는 사실을 모릅니다. 오직 자신이 만든 통계 정보만을 믿고 판단을 내립니다.

옵티마이저의 판단은 (부정확할 수 있는) 통계 정보를 기반으로 한 최선의 추측입니다.

비용이 더 쌀 것이라고 예상되면 그 비용이 싼 상황을 선택합니다.
