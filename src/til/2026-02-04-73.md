---
title: 전략 패턴
description: 전략 패턴은 무엇인가요?
date: 2026-02-04
tags: [전략 패턴]
---

전략 패턴은 실행 중에 알고리즘(전략)을 선택하여 객체의 동작을 실시간으로 바꿀  수 있게 해주는 행위 디자인 패턴입니다.

간단히 정의하면 “특정한 작업을 수행하는 알고리즘군을 정의하고, 각 알고리즘을 캡슐화하여, 이들을 상호 교체가 가능하게 만드는 패턴”입니다.

## 1. 구조

전략 패턴은 크게 3가지 요소로 구성됩니다.

1. Strategy (전략 인터페이스)
    - 모든 전략 구현체들이 반드시 구현해야 하는 공통 인터페이스입니다. 알고리즘을 호출하는 메소드가 정의됩니다.
2. ConcreteStrategy (구체적 전략)
    - Strategy 인터페이스를 실제로 구현한 클래스입니다. 구체적인 알고리즘 로직이 여기에 들어갑니다.
3. Context (컨텍스트)
    - Strategy를 이용하는 클라이언트(사용자)입니다.
    - 구체적인 전략 구현체를 직접 가지지 않고, Strategy 인터페이스를 참조합니다.
    - setStrategy() 같은 메소드를 통해 동적으로 전략을 변경할 수 있습니다.

## 2. 코드 예시

“물건을 구매할 때 결제 방식을 선택하는 로직”을 예로 들어보겠습니다.

### 1) Strategy 인터페이스 (공통 규격)

```java
public interface PaymentStrategy {
 void pay(int amount);
}
```

### 2) ConcreteStrategy (구체적 구현)

```java
public class CreditCardStrategy implements PaymentStrategy {
 public void pay(int amount) {
  ...
 }
}

public class KakaoPayStrategy implements PaymentStrategy {
 public void pay(int amount) {
  ...
 }
}
```

### 3) Context (사용 객체)

```java
public class ShoppingCart {
 private PaymentStrategy paymentStrategy;
 
 public void setPaymentStrategy(PaymentStrategy paymentStrategy){
  this.paymentStrategy = paymentStrategy;
 }
 
 public void checkout(int amount) {
  if (paymentStrategy == null) {
   ...
   return;
  }
  
  paymentStrategy.pay(amount);
 }
}
```

### 4) 실행

```java
public class Main {
 public static void main(String[] args) {
  ShoppingCart cart = new ShoppingCart();
  
  cart.setPaymentStrategy(new CreditCardStrategy());
  cart.chekout(10000);
  
  cart.setPaymentStrategy(new KakaoPayStrategy());
  cart.checkout(20000);
 }
]
```

## 3. 사용하는 이유

1. OCP (Open-Closed Principle) 준수

    가장 큰 장점입니다. 새로운 전략(예: 네이버페이)를 추가하고 싶을 때, 기존의 ShoppingCart 코드를 전혀 수정하지 않고 새로운 클래스만 만들어서 끼워 넣으면 됩니다.

1. if-else/switch 문 제거

    전략 패턴을 쓰지 않으면 아래와 같은 복잡한 분기문이 발생합니다.

    ```java
    public void checkout(String method, int amount) {
        if (method.equals("CARD")) {
            // 카드 결제 로직...
        } else if (method.equals("KAKAO")) {
            // 카카오 결제 로직...
        } else if (method.equals("NAVER")) {
            // 네이버 결제 로직...
        }
    }
    ```

    전략 패턴은 이 분기 로직을 다형성으로 대체하여 코드를 깔끔하게 만듭니다.

1. 상속 대신 위임 사용

    알고리즘을 상위 클래스에 박아넣고 상속받는 방식은 유연성이 떨어집니다. 전략 패턴은 구성을 통해 런타임 객체의 행동을 바꿀 수 있는 유연함을 제공합니다.

## 4. 단점

1. 클라이언트가 구체적인 전략을 알아야 함
    - 사용자는 어떤 전략(클래스)이 자신에게 필요한지 알고 직접 주입해줘야 합니다.
2. 클래스 수 증가
    - 전략 하나당 클래스 하나가 생성되므로, 전략이 많아지면 관리해야 할 클래스 파일이 늘어납니다.

## 정리

전략 패턴은 “알고리즘을 캡슐화하여 교체 가능하게 만드는 패턴”입니다. 복잡한 if-else 분기문을 제거하고, OCP를 지키며 시스템을 확장하고 싶을 때 사용하는 가장 대표적인 디자인 패턴입니다.
