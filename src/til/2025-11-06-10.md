---
title: 얕은 복사와 깊은 복사
description: 얕은 복사와 깊은 복사에 대해 알아봅시다.
date: 2025-11-06
tags: [Java, 얕은복사, 깊은 복사]
---

얕은 복사와 깊은 복사는 객체를 복사할 때, 해당 객체가 참조하고 있는 다른 객체들을 어떻게 처리하느냐에 따라 구분되는 핵심 개념입니다.

이 둘의 차이는 메모리 상에서 데이터가 공유되는지, 아니면 완전히 분리되는지로 귀결됩니다.

## 1. 얕은 복사

얕은 복사는 객체를 복사할 때, 해당 객체의 최상위 수준(Top-level)에 있는 필드 값들만 복사하는 방식입니다.

### 동작 방식

1. 복사 대상 객체와 동일한 타입의 새로운 객체를 생성합니다.
2. 원본 객체의 필드를 순회하며 값을 복사합니다.
3. Primitive Type (원시 타입 예: int, double, boolean): 실제 값이 그대로 복사됩니다. (값에 의한 복사)
4. Reference Type (참조 타입 예: Object, Array, List): 실제 객체가 복사되는 것이 아니라, 해당 객체를 가리키는 메모리 주소 값(참조)이 복사됩니다.

### 핵심 결과

복사된 객체(사본)와 원본 객체는 참조 타입 필드(내부 객체)를 공유하게 됩니다.

### 문제점

사본 객체를 통해 내부 객체(참조 타입 필드)의 상태를 변경하면, 원본 객체의 내부 객체 상태도 함께 변경됩니다.

두 객체가 물리적으로 동일한 내부 객체를 가리키고 있기 때문입니다.

### 비유

원본 객체를 ‘우리 집 정보’라고 가정합니다. ({ name: “A”, address: (0x100번지 주소) })

address는 실제 ‘집’ 객체를 가리키는 참조입니다.

얕은 복사를 하면 ‘사본 집 정보’가 생깁니다. ({ name: “A”, address: (0x100번지 주소) })

name(”A”)은 값이 복사되었지만, address는 0x100번지 주소라는 참조 값이 복사되었습니다.

원본과 사본, 두 개의 집 정보가 동일한 실제 집(0x100번지)을 가리킵니다.

## 2. 깊은 복사

깊은 복사는 객체를 복사할 때, 해당 객체는 물론, 그 객체가 참조하는 모든 하위 객체들까지 재귀적으로 복사하여 완전히 독립된 새로운 객체를 생성하는 방식입니다.

### 동작 방식

1. 복사 대상 객체와 동일한 타입의 새로운 객체를 생성합니다.
2. 원본 객체의 필드를 순회하며 값을 복사합니다.
3. Primitive Type: 실제 값이 그대로 복사됩니다. (얕은 복사와 동일)
4. Reference Type: 메모리 주소를 복사하는 대신, 해당 참조가 가리키는 객체 자체를 다시 깊은 복사하여 새로운 메모리 공간에 할당하고, 이 새 주소를 복사본 객체에 연결합니다. 이 과정은 모든 참조 타입에 대해 재귀적으로 반복됩니다.

### 핵심 결과

복사된 객체(사본)와 원본 객체는 완전히 독립적입니다. 어떤 내부 객체도 공유하지 않습니다.

### 장점

사본 객체의 내부 객체를 아무리 변경해서 원본 객체에 어떠한 영향도 주지 않습니다. 데이터의 불변성을 유지하고 부작용을 원천적으로 차단합니다.

### 비유

원본 객체를 ‘우리 집 정보’와 ‘집 설계도’라고 가정합니다. ({ name: “A”, address: (0x100번지 주소) })

깊은 복사를 하면, 먼저 ‘사본 집 정보’를 만듭니다.

name(”A”)은 값을 복사합니다.

address를 복사할 차례에, 0x100번지의 ‘집’을 찾아가 그 집의 ‘설계도’를 가져옵니다.

그 설계도를 바탕으로 다른 땅(0x200번지)에 완전히 새로운 집을 짓습니다.

‘사본 집 정보’에는 이 새 집의 주소(0x200번지 주소)를 기록합니다. ({ name: “A”, address: (0x200번지 주소) })

원본과 사본은 이름만 같을 뿐, 물리적으로 완전히 다른 두 채의 집을 가리킵니다.

## Java에서의 구현

### A. 얕은 복사

1. Object.clone(): Object 클래스의 clone() 메소드는 기본적으로 얕은 복사를 수행합니다. Cloneable 인터페이스를 구현하고 Clone()을 오버라이드해야 하지만, 내부의 참조 타입 필드를 개발자가 직접 복사해주지 않으면 주소 값만 복사됩니다.
2. 복사 생성자

   ```java
   public User(User original) {
   	this.name = original.name;
   	this.address = original.address; // 주소 값만 복사 (얕은 복사)
   }
   ```

### B. 깊은 복사

1. clone() 오버라이드를 통한 수동 구현: clone() 메소드를 오버라이드할 때, 내부의 참조 타입 필드에 대해서도 clone()을 재귀적으로 호출해줘야 합니다.

   ```java
   @Override
   protected Object clone() throws CloneNotSupportedException {
   	User cloned = (User) super.clone();
   	cloned.address = (Address) this.address.clone(); // 내부 객체도 복사 return cloned;
   }
   ```

2. 직렬화/역직렬화: 객체를 바이트 스트림으로 직렬화했다가, 그 스트림을 다시 객체로 역직렬화하는 방식입니다. 객체 그래프 전체가 새로운 메모리에 생성되므로 완벽한 깊은 복사가 됩니다. (하지만 비용이 매우 큽니다.)
3. 복사 생성자(수동 구현)

   ```java
   public User(User original) {
   	this.name = original.name;
   	this.address = new Address(original.address); // 내부 객체를 새로 생성 (깊은 복사)
   }
   ```
