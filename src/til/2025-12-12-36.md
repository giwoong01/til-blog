---
title: DB Replication
description: DB Replication은 무엇일까요?
date: 2025-12-12
tags: [DB]
---

DB 리플리케이션은 실시간으로 데이터를 복제하여 여러 데이터베이스 서버에 동일한 데이터를 유지하는 기술입니다.

가장 대중적인 방식은 “Master-Slave(Source-Replica)” 구조로, 서버의 역할을 쓰기 전용(Master)과 읽기 전용(Slave)으로 나누어 부하를 분산하고 안정성을 높이는 것입니다.

## 1. 기본 아키텍처 (Master-Slave 구조)

대부분의 웹 애플리케이션 트래픽은 읽기(SELECT)가 80%, 쓰기(INSERT/UPDAETE/DELETE)가 20%정도의 비율을 가집니다. 리플리케이션은 이 점에 착안합니다.

- Master (Primary)
  - 데이터의 원본을 관리합니다.
  - 쓰기(INSERT, UPDATE, DELETE) 요청을 전담합니다.
  - 데이터가 변경되면 이를 기록하여 Slave에게 전달합니다.
- Slave (Replica/Secondary)
  - Master의 데이터를 실시간으로 복제하여 동기화합니다.
  - 읽기(SELECT) 요청을 전담합니다.
  - 여러 대(Slave 1, Slave 2…)를 두어 읽기 트래픽을 분산시킬 수 있습니다. (Scale-out)

## 2. 동작 원리 (MySQL 기준)

MySQL에서 리플리케이션이 동작하는 내부 과정은 다음과 같습니다. 핵심은 바이너리 로그입니다.

1. 쓰기 요청: 클라이언트가 Master DB에 데이터를 씁니다.
2. Binlog 기록: Master는 변경 내용을 바이너리 로그 파일에 기록하고 트랜잭션을 커밋합니다.
3. 로그 전송: Slave DB의 I/O 스레드가 Master에 접속하여 “새로운 로그 내놔”라고 요청하면, Master는 Binlog 내용을 Slave에게 전송합니다.
4. Relay Log 기록: Slave는 받아온 데이터를 자신의 릴레이 로그에 기록합니다.
5. SQL 실행 (Replay): Slave의 SQL 스레드가 릴레이 로그를 읽어서, Master가 수행했던 SQL을 자신의 DB에도 똑같이 실행하여 데이터를 동기화합니다.

## 3. 리플리케이션을 하는 이유

1. 부하 분산 (Scale-out)
   - 가장 큰 목적입니다. 무거운 조회 쿼리(SELECT)를 여러 대의 Slave 서버로 분산시켜 Master의 부담을 줄이고 전체 시스템의 처리량을 늘립니다.
2. 고가용성
   - Master 서버가 갑자기 고장나도, 최신 데이터를 가진 Slave 서버 중 하나를 새로운 Master로 승격시켜 서비스를 중단 없이 유지할 수 있습니다.
3. 데이터 백업
   - 서비스 중인 Master 서버에서 백업을 수행하면 성능 저하가 발생할 수 있습니다. 대신 Slave 서버 중 하나를 골라 백업을 수행하면 서비스에 영향을 주지 않습니다.

## 4. 핵심 문제: 리플리케이션 지연

리플리케이션은 기본적으로 비동기 방식으로 작동합니다. 즉, Master에 쓴 직후 Slave에 반영되기까지 미세한 시간 차이가 발생합니다.

- 문제 상황
  1. 사용자가 게시글을 작성함 (Master에 INSERT)
  2. 작성 직후 자신의 게시글 목록을 조회함 (Slave에서 SELECT)
  3. 결과: Slave에 아직 데이터가 넘어오지 않아서, 방금 쓴 글이 안 보임.
- 해결 전략
  - 본인 읽기 쓰기: “내가 방금 쓴 데이터를 조회할 때”는 강제로 Master DB에서 읽어오도록 라우팅합니다.
  - 지연 시간이 짧다면 사용자 경험상 무시하거나, UI에서 잠시 로딩 처리를 합니다.

## 정리

DB 리플리케이션은 “쓰기는 Master, 읽기는 Slave”로 역할을 나누어 성능(부하 분산)과 안정성(장애 대응)을 동시에 잡는 기술입니다.

다만, Master와 Slave 사이의 데이터가 완벽하기 일치하지 않는 지연시간이 존재할 수 있음을 항상 염두에 두고 개발해야 합니다.
