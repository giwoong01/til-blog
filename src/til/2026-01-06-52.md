---
title: Redis가 싱글쓰레드인 이유
description: Redis가 싱글쓰레드로 만들어진 이유는 무엇일까요?
date: 2026-01-06
tags: [Redis, 쓰레드]
---

Redis가 싱글 쓰레드 방식을 채택한 것은 기술적 한계 때문이 아니라, Redis의 설계 철학과 주 사용 목적에 가장 부합하는 전략적인 선택입니다.

흔히 “싱글 쓰레드는 멀티 쓰레드보다 느리다”고 생각하기 쉽지만, Redis 환경에서는 오히려 싱글 쓰레드가 더 효율적입니다.

## 1. CPU는 병목이 아니다.

Redis는 데이터를 디스크가 아닌 메모리에 저장하고 조회합니다. 메모리 접근 속도는 매우 빠르기 때문에, Redis 성능의 한계는 CPU 연산 속도가 아니라 메모리 대역포이나 네트워크 대역폭에서 옵니다.

- 설명
  - Redis의 대부분 명령어(GET, SET 등)는 단순한 해시 테이블 조회이므로 CPU 처리가 거의 0에 가까운 시간(나노초)에 끝납니다.
- 결론
  - 굳이 멀티 쓰레드를 써서 CPU를 더 쓴다고 해도, 이미 네트워크 속도가 한계라서 성능 향상이 미미합니다.

## 2. 컨텍스트 스위칭 비용 제거

멀티 쓰레드 환경에서는 CPU가 여러 쓰레드를 번갈아 가며 실행하기 위해 컨텍스트 스위칭이 빈번하게 발생합니다.

- 문제점
  - 쓰레드를 전달하려면 현재 상태를 저장하고 다른 쓰레드를 불러오는 오버헤드가 발생합니다. Redis처럼 작업 하나하나가 매우 가벼운 경우, 작업을 처리하는 시간보다 쓰레드를 갈아 끼우는 시간이 더 걸리는 비효율이 발생할 수 있습니다.
- 이점
  - 싱글 쓰레드는 문맥 교환 없이 오직 작업 처리에만 집중할 수 있어 효율이 극대화됩니다.

## 3. 락 비용 및 경쟁 상태 해결

멀티 쓰레드 프로그래밍 가장 큰 골칫거리는 공유 자원에 대한 동기화 문제입니다.

- 문제점
  - 여러 쓰레드가 동시에 같은 키에 접근하면 데이터가 깨질 수 있습니다(Race Condition). 이를 막으려면 Mutex나 Semaphore 같은 락을 걸어야 하는데, 락을 걸고 푸는 과정 자체가 오버헤드이며 병목을 유발합니다.
- 이점
  - 싱글 쓰레드는 한 번에 하나의 명령어만 실행하므로, 원자성이 자연스럽게 보장됩니다. 복잡한 동기화 코드가 필요 없고, 데드락 걱정도 없습니다.

## 4. I/O 멀티플렉싱 기술 활용

“싱글 쓰레드인데 어떻게 수만 명의 요청을 동시에 처리하나요?”라는 질문의 답입니다.

- 원리
  - Redis는 싱글 쓰레드지만, Non-blocking I/O와 I/O 멀티플렉싱 기술을 사용하여 여러 클라이언트의 요청을 동시에 대기합니다.
- 비유
  - 식당에 요리사는 한 명이지만, 웨이터(I/O 멀티플렉서)가 여러 손님의 주문을 빠르게 받아 주방에 순서대로 던져주는 것과 같습니다. 요리 속도가 워낙 빨라서 손님들은 기다림을 거의 느끼지 못합니다.

## 주의사항

Redis는 싱글 쓰레드라서 생기는 명확한 단점과 변화도 있습니다.

1. 무거운 명령어 주의: KEYS \*, FLUSHALL 같이 처리 시간이 오래 걸리는 O(N) 명령어를 실행하면, 그 동안 다른 모든 요청이 멈춥니다(Blocking). 따라서 실무에서는 절대 사용해서는 안 됩니다.
2. Redis 6.0의 변화 (Threaded I/O)
   - Redis 6.0부터는 멀티 스레드 기능이 일부 도입되었습니다.
   - 하지만 명령어를 실행하는 핵심 로직은 여전히 싱글 쓰레드입니다.
   - 대신 네트워크 패킷을 읽고 쓰는 네트워크 I/O 처리 부분만 멀티 쓰레드로 분산시켜 성능을 더 끌어올렸습니다.

## 정리

Redis가 싱글 쓰레드인 이유는 CPU가 병목이 아니기 때문이며, 컨텍스트 스위칭과 락 오버헤드를 없애 단순하고 빠른 구조를 유지하기 위해서입니다.
