---
title: 응집도와 결합도
description: 응집도와 결합도는 무엇일까요?
date: 2026-01-05
tags: [응집도, 결합도]
---

응집도와 결합도는 좋은 소프트웨어 설계를 판단하는 가장 중요하고 기초적인 두 가지 기준입니다.

소프트웨어 공학의 대원칙은 항상 응징도는 높이고, 결합도는 낮추는 방향으로 설계하는 것입니다.

이 두 개념의 핵심 차이는 “관심의 대상이 모듈 내부냐(응집도), 모듈 간의 관계냐(결합도)”에 있습니다.

## 1. 응집도

응집도는 하나의 모듈(클래스, 함수, 패키지) 내부의 요소들이 얼마나 밀접하게 관련되어 있는지를 나타내는 척도입니다.

- 정의: 모듈 내부의 기능들이 하나의 책임(목적)을 위해 얼마나 집중되어 있는가?
- 지향점: 높은 응집도
  - 하나의 클래스는 하나의 책임만 가져야 합니다. (SRP - 단일 책임 원칙)
  - 모듈 안의 코드가 서로 강하게 연관되어 변수나 함수들이 함께 사용됩니다.

비교 예시

- 나쁜 예 (낮은 응집도): SuperManager 클래스
  - 이 클래스 안에서 회원 가입도 하고, 이메일도 보내고, 로그도 찍고, 결제도 처리함
  - 서로 상관없는 기능들이 잡동사니처럼 모여 있습니다. 하나를 수정하면 다른 엉뚱한 기능이 고장 날 위험이 큽니다.
- 좋은 예 (높은 응집도): EmailSender 클래스
  - 오직 이메일을 전송하는 기능과 관련된 코드만 모여 있습니다.
  - 이메일 전송 로직이 바뀌면 이 클래스만 수정하면 됩니다.

## 2. 결합도

결합도는 모듈과 모듈 사이의 의존성 정도를 나타내는 척도입니다.

- 정의: 한 모듈이 바뀔 때, 다른 모듈이 얼마나 영향을 받는가?
- 지향점: 낮은 결합도
  - 다른 모듈의 변경에 영향을 받지 않거나 최소화해야 합니다.
  - 이를 위해 인터페이스를 사용하거나 의존성 주입을 활용합니다.

비교 예시

- 나쁜 예 (높은 결합도)
  - A 클래스가 B 클래스의 public 필드를 직접 꺼내서 수정함
  - B 클래스의 변수명을 바꾸면 A 클래스도 에러가 나서 같이 수정해야 함
- 좋은 예 (낮은 결합도)
  - A 클래스는 B 클래스의 내부 구현을 모르고, B가 제공하는 메소드만 호출함
  - B 내부 로직이 싹 바뀌어도 메소드 이름과 리턴 타입만 같다면 A는 수정할 필요가 없음

## 정리

- 응집도: 각 블록은 단단하게 뭉쳐있어 잘 부서지지 않습니다.
- 결합도: 블록끼리 쉽게 끼웠다 뺐다 할 수 있어야 합니다.

Spring 프레임워크를 사용한다면 이미 이 원칙을 따르기 좋은 환경입니다.

- Controller, Service, Repository로 레이어를 나누는 것 → 응집도를 높이는 행위 (역할 분리)
- @Autowired로 인터페이스를 주입받아 사용하는 것 → 결합도를 낮추는 행위 (구현체 교체의 유연성 확보)
