---
title: 일급 컬렉션
description: 일급 컬렉션이 무엇인가요?
date: 2025-11-03
tags: [Spring Boot, Java, 일급 컬렉션]
---

# 일급 컬렉션이란?

컬렉션을 감싸는 단 하나의 필드만 가진 클래스를 말합니다.

즉, List, Set, Map 같은 컬렉션을 직접 노출하지 않고, 해당 컬렉션을 전담 관리하는 전용 객체로 감싸는 것입니다.

```java
public class Students {
    private final List<Student> students;

    public Students(List<Student> students) {
        this.students = new ArrayList<>(students);
    }

    public void add(Student student) {
        students.add(student);
    }

    public List<Student> getStudents() {
        return Collections.unmodifiableList(students);
    }

    public int count() {
        return students.size();
    }

    public boolean contains(Student student) {
        return students.contains(student);
    }
}
```

위 코드에서 Students 클래스는 List<Student>를 감사는 일급컬렉션입니다.

단순한 리스트가 아니라 “학생 목록이라는 도메인 개념”을 하나의 객체로 표현한 것 입니다.

# 왜 일급 컬렉션을 써야 할까?

## (1) 비즈니스 로직의 응집도 향상

기존에 로직이 여기저기 흩어져 있었을 것 입니다.

```java
List<Student> students = ...;
int count = students.size();
```

하지만 Students로 감싸면, 학생 목록과 관련된 모든 로직(추가, 검증, 필터링)이 한 곳에 모입니다.

```java
Students students = new Students(...);
int count = students.count();
```

“학생 목록”에 대한 책임은 오직 Students 객체만 가지게 됩니다.

응집도는 높아지고 결합도는 낮아집니다.

## (2) 불변성(Immutable) 유지 용이

일급 컬렉션은 내부 컬렉션을 직접 노출하지 않고, Collections.unmodifiableList()로 감싸면 외부에서 수정할 수 없습니다.

```java
public List<Student> getStudents() {
    return Collections.unmodifiableList(students);
}
```

즉, 컬렉션을 통한 데이터 변조를 방지하고 데이터 무결성을 보장할 수 있습니다.

## (3) 컬렉션에 대한 검증 로직을 내부로 숨김

예를 들어 “학생 수는 30명을 초과할 수 없다”는 제약 조건이 있다면?

```java
public class Students {
    private static final int MAX_SIZE = 30;

    private final List<Student> students;

    public Students(List<Student> students) {
        validateSize(students);
        this.students = new ArrayList<>(students);
    }

    private void validateSize(List<Student> students) {
        if (students.size() > MAX_SIZE) {
            throw new IllegalArgumentException("학생은 최대 30명까지 가능합니다.");
        }
    }
}
```

이제 외부에서는 List<Student>를 직접 다루지 않아도, Students 클래스가 자체적으로 도메인 제약을 보장하게 됩니다.

## (4) 중복 제거 및 객채 간 메시지 명확화

일급 컬렉션을 쓰면 “로직의 중복”을 방지할 수 있습니다.

예를 들어, 학생 중 특정 조건을 만족하는 학생을 찾는 로직이 여러 곳에서 반복될 필요 없이 Students 내부로 캡슐화할 수 있습니다.

```java
public List<Student> topScorers() {
    return students.stream()
                   .filter(s -> s.getScore() > 90)
                   .toList();
}
```

이제 Students 객체에게 “상위권 학생을 줘”라고 메시지를 보내는 식으로 바꿀 수 있습니다.

# 일급 컬렉션을 도입하면 좋은 시점

- 도메인에서 “목록” 자체가 의미를 가질때
  - 주문(OrderItems), 학생 목록(Students), 채팅 참가자(Participants)
- 컬렉션에 대한 제약이나 규칙이 있을 때
  - “최대 10명까지만 가능”, “중복 금지”
- 컬렉션 관련 연산이 여러 계층이 흩어질 때
  - 로직을 응집시켜 관리

# 일급 컬렉션을 쓰지 않았을 때의 문제점

아래 예시는 Order 엔티티가 있고, 주문 상품들을 List<OrderItem>으로 직접 들고 있는 전형적인 설계입니다.

```java
@Entity
public class Order {

    @Id @GeneratedValue
    private Long id;

    @OneToMany(mappedBy = "order", cascade = CascadeType.ALL)
    private List<OrderItem> orderItems = new ArrayList<>();

    public void addOrderItem(OrderItem item) {
        orderItems.add(item);
    }

    public int totalPrice() {
        return orderItems.stream()
                         .mapToInt(OrderItem::getPrice)
                         .sum();
    }
}
```

처음에는 “괜찮네?” 싶지만, 실제로 운영 환경에서는 다음과 같은 문제가 반드시 생깁니다.

## (1) 컬렉션 제약을 보장하기 어렵다

예를 들어 “주문 항목은 중복될 수 없다”는 규칙이 생겼다고 가정합니다.

이 로직을 Order 내부에서 직접 검증하면?

```java
public void addOrderItem(OrderItem item) {
    if (orderItems.contains(item)) {
        throw new IllegalArgumentException("중복된 주문 항목입니다.");
    }
    orderItems.add(item);
}
```

Order의 역할이 너무 많아집니다.

도메인 규칙 검증, 가격 계산, 주문 상태 변경 등 모든 책임이 한 클래스에 집중됩니다.

## (2) 컬렉션 관련 로직이 중복된다.

서비스 계층에서도, 도메인 내부에서도 같은 컬렉션 로직이 중복되기 쉽습니다.

```java
// OrderService
int totalPrice = order.getOrderItems()
                      .stream()
                      .mapToInt(OrderItem::getPrice)
                      .sum();
```

이런 코드가 여러 곳에 흩어지면 “주문 항목”이라는 개념이 명확히 캡슐화되지 않고, 비즈니스 로직이 산발적으로 퍼지게 됩니다.

## (3) 불변성이 깨질 수 있다

List<OrderItem>를 그대로 반환하면 외부에서 수정할 수 있습니다.

```java
order.getOrderItems().clear();
```

→ 도메인 객체의 무결성이 깨집니다.

→ 시스템 일관성 문제가 발생할 수 있습니다.

## (4) 컬렉션의 의미가 표현되지 않는다

단순한 List<OrderItem>는 “주문 항목들”이라는 의미를 전달하지 못합니다.

즉, 코드만 봐서는 “이게 어떤 제약을 가지는 집합인지” 파악이 어렵습니다.

# 일급 컬렉션을 적용한 개선 예시

이제 OrderItems라는 클래스를 만들어 “주무 항목 목록”자체를 하나의 객체로 다루도록 바꿔봅니다.

OrderItems 도입

```java
@Embeddable
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class OrderItems {

    @OneToMany(mappedBy = "order", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<OrderItem> values = new ArrayList<>();

    public OrderItems(List<OrderItem> items) {
        validateDuplicate(items);
        this.values = new ArrayList<>(items);
    }

    public void add(OrderItem item) {
        if (values.contains(item)) {
            throw new IllegalArgumentException("중복된 주문 항목입니다.");
        }
        values.add(item);
    }

    public int totalPrice() {
        return values.stream()
                     .mapToInt(OrderItem::getPrice)
                     .sum();
    }

    public List<OrderItem> getValues() {
        return Collections.unmodifiableList(values);
    }

    private void validateDuplicate(List<OrderItem> items) {
        long distinctCount = items.stream().distinct().count();
        if (distinctCount != items.size()) {
            throw new IllegalArgumentException("중복된 주문 항목이 존재합니다.");
        }
    }
}
```

Order 클래스 리팩토링

```java
@Entity
public class Order {

    @Id @GeneratedValue
    private Long id;

    @Embedded
    private OrderItems orderItems = new OrderItems();

    public int totalPrice() {
        return orderItems.totalPrice();
    }

    public void addOrderItem(OrderItem item) {
        orderItems.add(item);
    }
}
```

Order는 “주문 항목 관리”라는 책임을 OrderItems로 위임했습니다.

Order는 “주문 전체의 행위”만 신경 쓰면 됩니다.

# 마무리

일급 컬렉션은 단순한 컬렉션을 도메인 객체로 감싸 컬렉션 자체의 의미, 제약, 검증 로직을 응집시키는 객체 설계 기법입니다.

예를 들어, 주문 엔티티에서 List<OrderItem>을 직접 다루면 중복 검증, 총액 계산 같은 로직이 흩어지지만, 이를 OrderItems라는 일급 컬렉션으로 감싸면 도메인 규칙이 명확히 표현되고 컬렉션의 불변성과 무결성을 보장할 수 있습니다.
