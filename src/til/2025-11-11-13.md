---
title: equals와 hashCode 재정의
description: equals와 hashCode는 왜 함께 재정의해야 할까요?
date: 2025-11-11
tags: [Spring Boot, Java, equals, hashCode]
---

Java의 해시 기반 컬렉션(예: HashMap, HashSet, Hashtable)이 객체를 올바르게 인식하고 동작하도록 만들기 위한, Object 클래스에 명시된 논리적 계약을 지키기 위해서입니다.

간단히 말해, 이 계약을 어기면 HashMap에 데이터를 분명히 put()했는데도 get()으로 가져오지 못하는, 객체를 잃어버리는 문제가 발생합니다.

## Object 클래스의 핵심 계약

Java의 Object 클래스는 equals()와 hashCode()에 대해 다음과 같은 핵심 계약을 명시하고 있습니다.

“두 객체가 equals(Object) 메소드를 사용해 ‘같다’라고 판단되었다면, 이 두 객체는 반드시 동일한 hashCode() 값을 반환해야 한다.”

> 역은 성립하지 않습니다. hashCode()가 같다고 해서 eqauls()가 항상 true일 필요는 없습니다. 이를 해시 충돌(Hash Collision)이라고 합니다.

## 이 계약이 왜 필요한가? (HashMap의 동작 원리)

이 계약은 HashMap이나 HashSet이 데이터를 저장하고 검색하는 방식 때문에 필수적입니다. HashMap은 속도를 위해 2단계로 동작합니다.

[1단계] hashCode() - “어느 버킷에 넣을 것인가?” HashMap은 내부적으로 여러 개의 버킷을 가진 배열을 사용합니다. 어떤 객체를 저장할 때, 먼저 key.hashCode()를 호출하여 해시 코드를 얻습니다. 이 해시 코드를 기반으로 이 객체를 몇 번 버킷에 저장할지를 매우 빠르게 결정합니다.

[2단계] equals() - “버킷 안에서 누구인가?” 1단계에서 찾은 버킷으로 갔는데, 그 버킷 안에 이미 다른 객체들이 있을 수 있습니다(해시 충돌). HashMap은 이 버킷 안의 객체들을 하나씩 순회하면서 key.equals(existingKey)를 호출하며 “내가 찾던 객체가 바로 이 객체인가?”를 최종적으로 확인합니다.

## 계약 위반 시나리오

이것이 왜 둘 다 재정의해야 하는지에 대한 답변입니다.

- 테스트용 객체: Person { String name; }
- p1 = new Person("Woong");
- p2 = new Person("Woong");
- 우리의 논리적 의도: p1과 p2는 같은 “Woong”이므로, 논리적으로 동등해야 한다.

### 시나리오 1: equals()만 재정의한 경우 (최악)

equals()만 “이름(name)이 같으면 같다”고 재정의하고, hashCode()는 Object의 기본 구현(메모리 주소 기반)을 그대로 둔다고 가정합니다.

1. 객체 상태
   - p1.equals(p2) → true (우리가 name을 비교하도록 재정의함)
   - p1.hashCode() → 12345 (Object의 기본값, p1의 메모리 주소 기반)
   - p2.hashCode() → 67890 (Object의 기본값, p2의 메모리 주소 기반)
2. 계약 위반
   - “equals()가 true인데 hashCode()가 다릅니다.”
3. HashMap의 오작동
   - 저장: map.put(p1, “Developer”);
     1. p1.hashCode() (12345)를 호출합니다.
     2. HashMap은 p1 객체를 1번 버킷(12345번 버킷)에 저장합니다.
   - 조회: map.get(p2);
     1. p2.hashCode() (67890)를 호출합니다.
     2. Hashmap은 2번 버킷(67890번 버킷)으로 찾아갑니다.
     3. 2번 버킷은 비어있습니다.
     4. null을 반환합니다.
4. 결과
   - 논리적으로 동일한 객체(p2)로 p1의 값을 찾으려 했지만, “객체를 잃어버렸습니다.” HashMap은 p1과 p2가 전혀 다른 객체라고 판단합니다.

### 시나리오 2: hashCode()만 재정의한 경우

hashCode()만 “이름(name)의 해시코드”로 재정의하고, equals()는 object의 기본 구현(주소 비교 ==)을 그대로 둔다고 가정합니다.

1. 객체 상태
   - p1.hashCode() → 999 (”Woong”.hashcode())
   - p2.hashCode() → 999 (”Woong”.hashcode())
   - p1.equals(p2) → false (Object의 기본값, p1 == p2는 거짓)
2. 계약 위반
   - 계약 자체는 위반하지 않습니다. (해시 코드가 같아도 equals가 false일 수 있음)
   - 하지만 HashMap의 의도와 다르게 동작합니다.
3. HashMap의 오작동
   - 저장 1: map.put(p1, “Developer”);
     1. p1.hashCode() (999)를 호출하여 1번 버킷에 저장합니다.
   - 저장 2: map.put(p2. “Intern”);
     1. p2.hashCode() (999)를 호출하여 1번 버킷으로 찾아갑니다.
     2. 1번 버킷에 p1이 있는 것을 발견합니다.
     3. p2.equals(p1)을 호출합니다. → 결과는 false (기본 == 비교)
     4. HashMap은 p1과 p2가 해시코드는 같지만 다른 객체라고 판단합니다.
     5. p2를 1번 버킷의 다음 노드에 추가합니다.
4. 결과
   - 논리적으로는 “Woong"이라는 키가 하나여야 하는데, HashMap에 “Woong”이라는 키를 가진 데이터가 중복으로 저장됩니다. HashSet이었다면 중복이 허용되지 않아야 하는데 중복 저장되는 문제가 발생합니다.

## 요약

equals()를 재정의했다는 것은 “논리적 동등성” (예: 이름이 같으면 같다)을 개발자가 직접 저의하겠다는 뜻입니다.

hashCode()는 이 “논리적 동등성”을 기준으로 HashMap 등이 빠르게 객체를 찾을 수 있도록 버킷(위치)을 알려주는 규칙입니다.

따라서 equals()에서 사용한 핵심 필드(예: name)를 동일하게 사용하여 hashCode()도 재정의해야만, 두 메소드의 논리가 일치하여 해시 기반 컬렉션이 정상적으로 동작합니다.

## 실제 개발에서 마주치는 문제

### 해시맵 Key 객체의 불변성

HashMap이나 HashSet에 Key로 사용되는 객체는 반드시 불변하거나, 최소한 hashCode() 계산에 사용되는 필드가 변경되지 않아야 합니다.

- 이유: hashCode()는 객체를 put()하는 시점에 “저장할 버킷 위치”를 계산하기 위해 사용됩니다.
- 문제 상황
  1. Person p1 = new Person(”Pobi”); (hashCode = 100)
  2. map.put(p1, “Developer”); (p1은 100번 버킷에 저장됨)
  3. p1.setName(”Roo”); (p1 객체의 필드 값을 변경함)
  4. 이제 p1.hashCode()를 다시 계산하면 “Roo” 기반의 값 (hashCode = 200)이 나옵니다.
  5. map.get(p1);을 실행하면, HashMap은 p1의 현재 hashCode(200)를 기준으로 200번 버킷을 찾아갑니다.
  6. 하지만 p1객체는 put()시점의 hashCode인 100번 버킷에 저장되어 있습니다.
- 결과: 200번 버킷에는 p1이 없으므로 null이 반환됩니다. put()을 분명히 했음에도 불구하고 객체를 다시는 찾을 수 없게 됩니다.

이것이 String이나 Integer같은 불변 객체가 Map의 Key로 사용하기에 가장 완벽한 이유입니다.

### hashCode()의 성능 - 좋은 분배

equals()가 true일 때 hashCode()가 같아야 한다는 계약은 최소한의 요구사항 입니다.

hashCode()의 진짜 목적은 객체들을 여러 버킷에 최대한 균일하게 분배하여 HashMap의 성능을 O(1)에 가깝게 유지하는 것입니다.

- 최악의 hashCode() 구현 (계약은 지켰지만 나쁨)
  ```java
  @Override
  public int hashCode() {
      return 1; // 모든 객체가 동일한 해시코드를 반환
  }
  ```
- 문제: 모든 객체가 hashCode()로 1을 반환하면, HashMap은 모든 데이터를 단 하나의 버킷에 저장하게 됩니다.
- 결과: 이 버킷은 사실상 LinkedList가 되며, get()을 할때마다 equals()로 버킷 안의 모든 객체를 순차 탐색합니다. HashMap을 쓰는 의미가 사라지고 성능이 O(N)(선형 시간)으로 저하됩니다.

좋은 hashCode()는 객체들을 여러 버킷에 골고루 흩뿌려 충돌을 최소화하는 것입니다.

### 현대적인 Java 구현 방법

과거에는 equals/hashCode를 손으로 직접 구현하는 것이 매우 복잡하고 오류가 발생하기 쉬웠습니다.

- Objects 헬퍼 클래스 (Java 7+) java.util.objects 클래스는 이 두 메소드를 안전하고 쉽게 구현하도록 도와줍니다.

  ```java
  @Override
  public boolean equals(Object o) {
      if (this == o) return true;
      if (o == null || getClass() != o.getClass()) return false;
      Person person = (Person) o;
      // Objects.equals()는 내부적으로 null 검사를 수행해 줌
      return Objects.equals(name, person.name) &&
             Objects.equals(age, person.age);
  }

  @Override
  public int hashCode() {
      // Objects.hash()는 필드들을 기반으로 좋은 품질의 해시코드를 생성해 줌
      return Objects.hash(name, age);
  }
  ```

- record 키워드 (Java 14+) 데이터를 담기 위한 불볍 객체라면 record를 사용하는 것이 가장 이상적입니다.
  ```java
  // 단 한 줄로 선언
  public record Person(String name, Integer age) { }
  ```
  record는 컴파일 시점에 name과 age 필드를 기반으로 하는 equals(), hashCode(), toString() 및 생성자를 자동으로 완벽하게 생성해 줍니다. 위에서 설명한 모든 계약과 성능 이슈를 완벽하게 해결합니다.

### JPA 엔티티와 equals/hashCode

JPA 엔티티(@Entity)에서 equals/hashCode를 재정의하는 것은 매우 위험하고 복잡한 문제입니다.

HashMap이나 HashSet에 엔티티를 담을 때 문제가 발생합니다.

- 문제 1: 프록시 객체
  - JPA는 성능을 위해 지연 로딩을 사용하며, 이때 원본 객체 대신 userProxy같은 프록시 객체를 반환합니다.
  - equals()를 getClass() ≠ o.getClass()로 구현했다면, User와 UserProxy는 다르다고 판단하여 false를 반환합니다. (instanceof User를 사용해야함)
- 문제 2: id가 null인 상태
  - hashCode()를 @Id 필드(PK)로 구현했다고 가정해 봅시다.
  - new User(”Pobi”)를 생성하고 HashSet에 add()합니다. 이때 id는 null이므로 hashCode는 0입니다.
  - 이 user를 save()하면 DB가 id를 할당해줍니다.
  - 이제 이 user의 hashCode는 1이됩니다.
  - 결과: 1번 항목에서 설명한 불변성 위배 문제가 발생합니다. HashSet은 HashCode 0을 기준으로 객체를 저장햇는데, 객체의 hashCode가 1로 바뀌었으므로 contains()등으로 이 객체를 찾을 수 없게 됩니다.
- 해결책, 권장 사항
  - 엔티티 자체를 Set이나 Map의 Key로 사용하는 것을 가급적 피합니다.
  - 꼭 사용해야 한다면, @Id가 아닌 비즈니스 키(email, username처럼 값이 변하지 않고 유일성이 보장되는 값)를 기반으로 equals/hashCode를 구현합니다.
  - 그것도 없다면 차라리 Object의 기본 구현을 그대로 두는 것이 더 안전할 수 있습니다.
